<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * PersistentObject.php
 *
 * This file contains the definition of the {@link PersistentObject} class.
 */

namespace OntologyWrapper;

use OntologyWrapper\Wrapper;
use OntologyWrapper\OntologyObject;
use OntologyWrapper\DatabaseObject;
use OntologyWrapper\CollectionObject;

/*=======================================================================================
 *																						*
 *								PersistentObject.php									*
 *																						*
 *======================================================================================*/

/**
 * Persistent object
 *
 * This &lt;i&gt;abstract&lt;/i&gt; class is the ancestor of all classes representing objects that can
 * persist in a container and that are constituted by ontology offsets.
 *
 * The main purpose of this class is to add the status and persistence traits providing the
 * prototypes needed to implement concrete persistent objects.
 *
 * The class makes use of the {@link Status} and {@link Persistence} traits:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link Status}&lt;/tt&gt;: This class handles a bitfirld data member that keeps
 *		track of the object's status:
 *	 &lt;ul&gt;
 *		&lt;li&gt;&lt;tt&gt;{@link isDirty()}&lt;/tt&gt;: This flag is set whenever any offset is modified,
 *			this status can be tested whenever the object should be stored in a persistent
 *			container: if set, it means the object has been modified, if not set, it means
 *			that the object is identical to the persistent copy.
 *		&lt;li&gt;&lt;tt&gt;{@link isCommitted()}&lt;/tt&gt;: This flag is set whenever the object has been
 *			loaded or stored into a persistent container. This status can be useful to lock
 *			properties that cannot change once the object is stored.
 *	 &lt;/ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link Persistence}&lt;/tt&gt;: This class handles the object persistence.
 * &lt;/ul&gt;
 *
 * Objects derived from this class &lt;em&gt;must&lt;/em&gt; define a constant called &lt;em&gt;kSEQ_NAME&lt;/em&gt;
 * which provides a &lt;em&lt;string&lt;/em&gt; representing the &lt;em&gt;default collection name&lt;/em&gt; for
 * the current object: methods that commit or read objects of a specific class can then
 * resolve the collection given a database.
 *
 *	@author		Milko A. &Scaron;kofiƒç &lt;m.skofic@cgiar.org&gt;
 *	@version	1.00 14/02/2014
 */
abstract class PersistentObject extends OntologyObject
{
	/**
	 * Status trait.
	 *
	 * In this class we handle the {@link is_committed()} flag.
	 */
	use	traits\Status;

		

/*=======================================================================================
 *																						*
 *										MAGIC											*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	__construct																		*
	 *==================================================================================*/

	/**
	 * Instantiate class.
	 *
	 * Objects derived from this class share the same constructor prototype, they should not
	 * overload this method. The method accepts two parameters:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;b&gt;$theContainer&lt;/b&gt;: This may either be an array containing the object's
	 *		persistent attributes, or a reference to a {@link Wrapper} object. If this
	 *		parameter is &lt;tt&gt;NULL&lt;/tt&gt;, the next parameter will be ignored.
	 *	&lt;li&gt;&lt;b&gt;$theIdentifier&lt;/b&gt;: This parameter represents the object identifier or the
	 *		object persistent attributes: in the first case it will used to select the
	 *		object from the provided container, in the second case, it is assumed that the
	 *		provided array holds the persistent attributes of an object committed in the
	 *		provided container.
	 * &lt;/ul&gt;
	 *
	 * The workflow is as follows:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;i&gt;Empty object&lt;/i&gt;: Both parameters are omitted.
	 *	&lt;li&gt;&lt;i&gt;Filled non committed object&lt;/i&gt;: The first parameter is an array.
	 *	&lt;li&gt;&lt;i&gt;Load object from container&lt;/i&gt;: The first parameter is a {@link Wrapper}
	 *		object and the second parameter is a scalar identifier.
	 *	&lt;li&gt;&lt;i&gt;Filled committed object&lt;/i&gt;: The first parameter is {@link Wrapper} object
	 *		and the second parameter is an array holding the object's persistent data.
	 * &lt;/ul&gt;
	 *
	 * Any other combination will raise an exception.
	 *
	 * This constructor sets the committed flag, derived classes should first call the
	 * parent constructor, then they should set the inited flag.
	 *
	 * @param ConnectionObject		$theContainer		Persistent store.
	 * @param mixed					$theIdentifier		Object identifier.
	 *
	 * @access public
	 *
	 * @throws Exception
	 *
	 * @uses ResolveDatabase()
	 * @uses ResolveCollection()
	 * @uses isCommitted()
	 */
	public function __construct( $theContainer = NULL, $theIdentifier = NULL )
	{
		//
		// Instantiate empty object.
		//
		if( $theContainer === NULL )
			parent::__construct();
		
		//
		// Instantiate from object attributes array.
		//
		elseif( is_array( $theContainer ) )
			parent::__construct( $theContainer );
		
		//
		// Instantiate from object.
		//
		elseif( ($theIdentifier === NULL)
		 &amp;&amp; ($theContainer instanceof \ArrayObject) )
			parent::__construct( $theContainer-&gt;getArrayCopy() );
		
		//
		// Handle wrapper.
		//
		elseif( $theContainer instanceof Wrapper )
		{
			//
			// Set dictionary.
			//
			$this-&gt;dictionary( $theContainer );
			
			//
			// Resolve collection.
			//
			$collection
				= static::ResolveCollection(
					static::ResolveDatabase( $theContainer, TRUE ) );
			
			//
			// Open collection.
			//
			$collection-&gt;openConnection();
			
			//
			// Load object data.
			//
			if( is_array( $theIdentifier ) )
			{
				//
				// Set committed status.
				//
				$this-&gt;isCommitted( TRUE );
				
				//
				// Call parent constructor.
				//
				parent::__construct( $theIdentifier );
				
			} // Provided data.
			
			//
			// Resolve object.
			//
			else
			{
				//
				// Find object.
				//
				$found = $collection-&gt;resolve( $theIdentifier, kTAG_NID, FALSE );
				if( $found !== NULL )
				{
					//
					// Set committed status.
					//
					$this-&gt;isCommitted( TRUE );
				
					//
					// Call parent constructor.
					//
					parent::__construct( $found );
				
				} // Found.
				
				//
				// Not found.
				//
				else
					parent::__construct();
			
			} // Provided identifier.
		
		} // Container connection.
		
		else
			throw new \Exception(
				&quot;Cannot instantiate object: &quot;
			   .&quot;invalid container parameter type.&quot; );							// !@! ==&gt;

	} // Constructor.

		

/*=======================================================================================
 *																						*
 *								PUBLIC PERSISTENCE INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	commit																			*
	 *==================================================================================*/

	/**
	 * Insert the object
	 *
	 * This method should commit the current object into the provided persistent store.
	 *
	 * In this method we perform the following steps:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;We resolve the eventually provided persistent store into a collection object,
	 *		or we use the current object's collection; if this is not set, or if the
	 *		collection canot be resolved, the method will raise an exception.
	 *	&lt;li&gt;We call the &lt;tt&gt;{@link preCommit()}&lt;/tt&gt; method that is responsible for
	 *		preparing the object for being committed.
	 *	&lt;li&gt;If the object is not ready, {@link isReady()}, we raise an exception.
	 *	&lt;li&gt;We pass the current object to the collection's commit method and recuperate the
	 *		identifier.
	 *	&lt;li&gt;We call the &lt;tt&gt;{@link postCommit()}&lt;/tt&gt; method that is responsible of cleaning
	 *		up the objecxt after the commit.
	 *	&lt;li&gt;We return the object's identifier.
	 * &lt;/ul&gt;
	 *
	 * If any of the above steps fail the method must raise an exception.
	 *
	 * @param Wrapper				$theWrapper			Persistent store.
	 *
	 * @access public
	 * @return mixed				The object's native identifier.
	 *
	 * @throws Exception
	 *
	 * @uses isDirty()
	 * @uses isCommitted()
	 * @uses dictionary()
	 * @uses ResolveDatabase()
	 * @uses ResolveCollection()
	 * @uses preCommit()
	 * @uses isReady()
	 * @uses postCommit()
	 */
	public function commit( Wrapper $theWrapper )
	{
		//
		// Do it only if the object is dirty or not committed.
		//
		if( $this-&gt;isDirty()
		 || (! $this-&gt;isCommitted()) )
		{
			//
			// Set dictionary wrapper.
			//
			$this-&gt;dictionary( $theWrapper );
			
			//
			// Resolve collection.
			//
			$collection
				= static::ResolveCollection(
					static::ResolveDatabase( $theWrapper, TRUE ) );
			
			//
			// Compute operation.
			//
			$op = 0x01;										// Signal saving.
			$op |= ( $this-&gt;isCommitted() ) ? 0x10 : 0x00;	// Signal committed.
		
			//
			// Prepare object.
			//
			$this-&gt;preCommit( $op );
		
			//
			// Commit.
			//
			$id = $collection-&gt;commit( $this );
	
			//
			// Copy identifier if new.
			//
			if( ! $this-&gt;isCommitted() )
				$this-&gt;offsetSet( kTAG_NID, $id );
		
			//
			// Cleanup object.
			//
			$this-&gt;postCommit( $op );
	
			//
			// Set object status.
			//
			$this-&gt;isDirty( FALSE );
			$this-&gt;isCommitted( TRUE );
		
		} // Dirty or not committed.
		
		return $this-&gt;offsetGet( kTAG_NID );										// ==&gt;
	
	} // commit.

		

/*=======================================================================================
 *																						*
 *								STATIC CONNECTION INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	ResolveDatabase																	*
	 *==================================================================================*/

	/**
	 * Resolve the database
	 *
	 * This method should return a {@link DatabaseObject} instance corresponding to the
	 * default database of the current class extracted from the provided {@link Wrapper}
	 * instance.
	 *
	 * Since we cannot declare this method abstract, we raise an exception.
	 *
	 * @param Wrapper				$theWrapper			Wrapper.
	 * @param boolean				$doAssert			Raise exception if unable.
	 * @param boolean				$doOpen				&lt;tt&gt;TRUE&lt;/tt&gt; open connection.
	 *
	 * @static
	 * @return DatabaseObject		Database or &lt;tt&gt;NULL&lt;/tt&gt;.
	 *
	 * @throws Exception
	 */
	static function ResolveDatabase( Wrapper $theWrapper, $doAssert = TRUE, $doOpen = TRUE )
	{
		throw new \Exception(
			&quot;Unable to resolve database: &quot;
		   .&quot;this method must be implemented.&quot; );								// !@! ==&gt;
	
	} // ResolveDatabase.

	 
	/*===================================================================================
	 *	ResolveCollection																*
	 *==================================================================================*/

	/**
	 * Resolve the collection
	 *
	 * This method should return a {@link CollectionObject} instance corresponding to the
	 * persistent store in which the current object was either read or will be inserted.
	 *
	 * The method expects the object to feature a constant, {@link kSEQ_NAME}, which serves
	 * the double purpose of providing the default collection name and the eventual sequence
	 * number index: the method will use this constant and the provided database reference
	 * to return the default {@link CollectionObject} instance.
	 *
	 * @param DatabaseObject		$theDatabase		Database reference.
	 * @param boolean				$doOpen				&lt;tt&gt;TRUE&lt;/tt&gt; open connection.
	 *
	 * @static
	 * @return CollectionObject		Collection or &lt;tt&gt;NULL&lt;/tt&gt;.
	 */
	static function ResolveCollection( DatabaseObject $theDatabase, $doOpen = TRUE )
	{
		return $theDatabase-&gt;Collection( static::kSEQ_NAME, $doOpen );				// ==&gt;
	
	} // ResolveCollection.

		

/*=======================================================================================
 *																						*
 *								PROTECTED COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preCommit																		*
	 *==================================================================================*/

	/**
	 * Prepare object for commit
	 *
	 * This method should prepare the object for being committed, it should compute the
	 * eventual identifiers and commit the eventual related objects.
	 *
	 * The method accepts a single bitfield parameter that indicates the current operation:
	 * the first bit is set if the object is committed and the second bit is set if we are
	 * storing the object.
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;0x01&lt;/tt&gt;: &lt;em&gt;Insert&lt;/em&gt;
	 *	 &lt;ul&gt;
	 *		&lt;li&gt;Check if the object is {@link isInited()}.
	 *		&lt;li&gt;&lt;tt&gt;{@link preCommitValidate()&lt;/tt&gt;: Validate object.
	 *		&lt;li&gt;&lt;tt&gt;{@link preCommitIdentify()&lt;/tt&gt;: Set object identifiers.
	 *		&lt;li&gt;&lt;tt&gt;{@link isReady()&lt;/tt&gt;: Check if object is ready.
	 *		&lt;li&gt;&lt;tt&gt;{@link preCommitRelated()&lt;/tt&gt;: Commit related objects.
	 *	 &lt;/ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;0x11&lt;/tt&gt;: &lt;em&gt;Update&lt;/em&gt;
	 *	 &lt;ul&gt;
	 *		&lt;li&gt;Nothing yet (this operation should not be implemented).
	 *	 &lt;/ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;0x10&lt;/tt&gt;: &lt;em&gt;Delete&lt;/em&gt;
	 *	 &lt;ul&gt;
	 *		&lt;li&gt;Check if the object has its native identifier, {@link kTAG_NID}.
	 *	 &lt;/ul&gt;
	 * &lt;/ul&gt;
	 *
	 * Derived classes should not overload this method, they should, instead, overload the
	 * called methods.
	 *
	 * @param bitfield				$theOperation		Operation code.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @see kTAG_NID
	 *
	 * @uses isInited()
	 */
	protected function preCommit( $theOperation = 0x00 )
	{
		//
		// Handle commit and update.
		//
		if( $theOperation &amp; 0x01 )
		{
			//
			// Validate object.
			//
			$this-&gt;preCommitValidate();
			
			//
			// Identify object.
			//
			$this-&gt;preCommitIdentify();
		
			//
			// Check if object is ready.
			//
			if( ! $this-&gt;isReady() )
				throw new \Exception(
					&quot;Cannot commit object: &quot;
				   .&quot;the object is not yet initialised.&quot; );						// !@! ==&gt;
			
			//
			// Commit related.
			//
			$this-&gt;preCommitRelated();
		
		} // Saving.
		
		//
		// Handle delete.
		//
		else
		{
			//
			// Ensure the object has its native identifier.
			//
			if( ! \ArrayObject::offsetExists( kTAG_NID ) )
				throw new \Exception(
					&quot;Unable to delete: &quot;
				   .&quot;the object is missing its native identifier.&quot; );			// !@! ==&gt;
		
		} // Deleting.
	
	} // preCommit.

	 
	/*===================================================================================
	 *	preCommitValidate																*
	 *==================================================================================*/

	/**
	 * Validate object before commit
	 *
	 * This method should validate the object before being committed, if the object is not
	 * valid, the method should raise an exception. Derived classes should call the parent
	 * method and do the specific checks.
	 *
	 * In this class we check whether the object is initialised.
	 *
	 * @access protected
	 */
	protected function preCommitValidate()
	{
		//
		// Check if initialised.
		//
		if( ! $this-&gt;isInited() )
			throw new \Exception(
				&quot;Unable to commit: &quot;
			   .&quot;the object is not initialised.&quot; );								// !@! ==&gt;
	
	} // preCommitValidate.

	 
	/*===================================================================================
	 *	preCommitIdentify																*
	 *==================================================================================*/

	/**
	 * Set object identifiers before commit
	 *
	 * This method should set the object identifiers.
	 *
	 * In this class we do nothing.
	 *
	 * @access protected
	 */
	protected function preCommitIdentify()												   {}

	 
	/*===================================================================================
	 *	preCommitRelated																*
	 *==================================================================================*/

	/**
	 * Commit related objects
	 *
	 * This method should commit related objects before the current object is committed.
	 *
	 * In this class we do nothing.
	 *
	 * @access protected
	 */
	protected function preCommitRelated()												   {}

	 
	/*===================================================================================
	 *	postCommit																		*
	 *==================================================================================*/

	/**
	 * Cleanup object after commit
	 *
	 * This method should cleanup the object after it was committed, it should perform
	 * eventual identifiers and commit the eventual related objects.
	 *
	 * The method accepts a single bitfield parameter that indicates the current operation:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;0x01&lt;/tt&gt;: Insert.
	 *	&lt;li&gt;&lt;tt&gt;0x11&lt;/tt&gt;: Update.
	 *	&lt;li&gt;&lt;tt&gt;0x10&lt;/tt&gt;: Delete.
	 * &lt;/ul&gt;
	 *
	 * The first bit is set if the object is committed and the second bit is set if we are
	 * storing the object.
	 *
	 * In this class we do nothing.
	 *
	 * @param bitfield				$theOperation		Operation code.
	 *
	 * @access protected
	 */
	protected function postCommit( $theOperation = 0x00 )								   {}

		

/*=======================================================================================
 *																						*
 *								PROTECTED STATUS INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	isReady																			*
	 *==================================================================================*/

	/**
	 * Check if object is ready
	 *
	 * This method should return &lt;tt&gt;TRUE&lt;/tt&gt; if the object is ready to be committed.
	 *
	 * In this class we ensure the object is initialised and that it holds the dictionary.
	 *
	 * @access protected
	 * @return Boolean				&lt;tt&gt;TRUE&lt;/tt&gt; means ready.
	 */
	protected function isReady()
	{
		return ( $this-&gt;isInited()
			  &amp;&amp; ($this-&gt;mDictionary !== NULL) );									// ==&gt;
	
	} // isReady.

		

/*=======================================================================================
 *																						*
 *							PROTECTED ARRAY ACCESS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before setting it
	 *
	 * We overload this method to prevent modifying the global and native identifiers if the
	 * object is committed, {@link isCommitted()}.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 * @return mixed				&lt;tt&gt;NULL&lt;/tt&gt; set offset value, other, return.
	 *
	 * @throws Exception
	 *
	 * @uses isCommitted()
	 * @uses InternalOffsets()
	 */
	protected function preOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Resolve offset.
		//
		$ok = parent::preOffsetSet( $theOffset, $theValue );
		if( $ok === NULL )
		{
			//
			// Check if committed.
			//
			if( $this-&gt;isCommitted() )
			{
				//
				// Check immutable tags.
				//
				if( in_array( $theOffset, $this-&gt;lockedOffsets() ) )
					throw new \Exception(
						&quot;Cannot set the [$theOffset] offset: &quot;
					   .&quot;the object is committed.&quot; );							// !@! ==&gt;
		
			} // Object is committed.
		
		} // Intercepted by preflight.
		
		return $ok;																	// ==&gt;
	
	} // preOffsetSet.

	 
	/*===================================================================================
	 *	postOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value after setting it
	 *
	 * We overload the parent method to set the {@link isDirty()} status.
	 *
	 * In this class we do nothing.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 *
	 * @uses isDirty()
	 */
	protected function postOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Resolve offset.
		//
		$ok = parent::postOffsetSet( $theOffset, $theValue );
		if( $ok === NULL )
			$this-&gt;isDirty( TRUE );
		
		return $ok;																	// ==&gt;
		
	} // postOffsetSet.

	 
	/*===================================================================================
	 *	preOffsetUnset																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before deleting it
	 *
	 * We overload this method to prevent modifying the global and native identifiers if the
	 * object is committed, {@link isCommitted()}.
	 *
	 * @param reference				$theOffset			Offset reference.
	 *
	 * @access protected
	 * @return mixed				&lt;tt&gt;NULL&lt;/tt&gt; delete offset value, other, return.
	 *
	 * @throws Exception
	 *
	 * @uses isCommitted()
	 * @uses lockedOffsets()
	 */
	protected function preOffsetUnset( &amp;$theOffset )
	{
		//
		// Resolve offset.
		//
		$ok = parent::preOffsetUnset( $theOffset );
		if( $ok === NULL )
		{
			//
			// Check if committed.
			//
			if( $this-&gt;isCommitted() )
			{
				//
				// Check immutable tags.
				//
				if( in_array( $theOffset, $this-&gt;lockedOffsets() ) )
					throw new \Exception(
						&quot;Cannot delete the [$theOffset] offset: &quot;
					   .&quot;the object is committed.&quot; );							// !@! ==&gt;
		
			} // Object is committed.
		
		} // Intercepted by preflight.
		
		return $ok;																	// ==&gt;
	
	} // preOffsetUnset.

	 
	/*===================================================================================
	 *	postOffsetUnset																	*
	 *==================================================================================*/

	/**
	 * Handle offset after deleting it
	 *
	 * This method can be used to manage the object after calling the
	 * {@link ArrayObject::OffsetUnset()} method.
	 *
	 * In this class we do nothing.
	 *
	 * @param reference				$theOffset			Offset reference.
	 *
	 * @access protected
	 *
	 * @uses isDirty()
	 */
	protected function postOffsetUnset( &amp;$theOffset )
	{
		//
		// Resolve offset.
		//
		$ok = parent::postOffsetUnset( $theOffset );
		if( $ok === NULL )
			$this-&gt;isDirty( TRUE );
		
		return $ok;																	// ==&gt;
		
	} // postOffsetUnset.

		

/*=======================================================================================
 *																						*
 *							PROTECTED OFFSET STATUS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	lockedOffsets																	*
	 *==================================================================================*/

	/**
	 * Return list of locked offsets
	 *
	 * This method should return the list of locked offsets, that is, the offsets which
	 * cannot be modified once the object has been committed.
	 *
	 * In this class we return the list of internal tags.
	 *
	 * @access protected
	 * @return array				List of locked offsets.
	 *
	 * @uses InternalOffsets()
	 */
	protected function lockedOffsets()				{	return $this-&gt;InternalOffsets();	}

	 

} // class PersistentObject.


?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>