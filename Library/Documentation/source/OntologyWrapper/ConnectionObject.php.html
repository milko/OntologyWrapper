<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * ConnectionObject.php
 *
 * This file contains the definition of the {@link ConnectionObject} class.
 */

namespace OntologyWrapper;

use OntologyWrapper\OntologyObject;

/*=======================================================================================
 *																						*
 *								ConnectionObject.php									*
 *																						*
 *======================================================================================*/

/**
 * Connection object
 *
 * This &lt;i&gt;abstract&lt;/i&gt; class is the ancestor of all classes representing connection
 * instances, such as servers, databases and collections.
 *
 * The main purpose of this class is to wrap a common interface around concrete instances of
 * specific server, database or collection or engines.
 *
 * The class features the following properties:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link $mDSN}&lt;/tt&gt;: The &lt;i&gt;data source name&lt;/i&gt;, it is an URL that represents
 *		the connection string.
 *	&lt;li&gt;&lt;tt&gt;{@link $mConnection}&lt;/tt&gt;: The &lt;i&gt;connection resource&lt;/i&gt;, it represents the
 *		native connection.
 *	&lt;li&gt;&lt;tt&gt;{@link $mParent}&lt;/tt&gt;: The &lt;i&gt;parent connection&lt;/i&gt;, it represents the instance
 *		derived from this class that instantiated the current object.
 * &lt;/ul&gt;
 *
 * The object is instantiated by providing a parameter that may either be a connection URL,
 * such as a string that may be parsed by the {@link parse_url()} function, or an array
 * containing the connection parameters.
 *
 * The public interface of this class, as well as for many other abstract classes, is
 * implemented as templates in which protected methods do the actual work, so derived
 * concrete classes should only need to implement the protected interface.
 *
 * This class declares three methods for managing the connection:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link isConnected()}&lt;/tt&gt;: Returns &lt;tt&gt;TRUE&lt;/tt&gt; if the connection is open.
 *	&lt;li&gt;&lt;tt&gt;{@link openConnection()}&lt;/tt&gt;: Create and open the connection.
 *	&lt;li&gt;&lt;tt&gt;{@link closeConnection()}&lt;/tt&gt;: Close and reset the connection.
 * &lt;/ul&gt;
 *
 * When the object goes out of context it will close the connection, if open, and re-open it
 * once it gets back into context:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link __sleep()}&lt;/tt&gt;: This method will close the connection, if open, and
 *		set the {@link $mConnection connection} property to &lt;tt&gt;TRUE&lt;/tt&gt; as an indication
 *		that the connection must be opened once the object gets back into scope.
 *	&lt;li&gt;&lt;tt&gt;{@link __wakeup()}&lt;/tt&gt;: This method will open the connection, if the object
 *		went out of scope while the connection was open.
 * &lt;/ul&gt;
 *
 * The class provides accessor methods for the object properties: the {@link $mDSN} data
 * member can be managed with the {@link DSN()} method, the {@link $mConnection} data
 * member can be retrieved with the {@link Connection()} method and the {@link $mParent}
 * data member can be retrieved with the {@link Parent()} method.
 *
 * When setting the connection string, {@link DSN()}, the object's connection parameters
 * will be synchronised. When setting offsets, the data source name will not be changed.
 * When the connection is opened, {@link openConnection()}, the data source name will be
 * re-constituted using the object's offsets. This means that the object offsets represent
 * the actual connection parameters, although setting the DSN will reset these parameters to
 * match the connection URL.
 *
 * When the connection is {@link isConnected() open}, any attempt to modify the object
 * offsets will raise an exception: this is to prevent changing the connection properties
 * while connected.
 *
 * In this class we make use of the {@link Status} trait, here we set the
 * {@link isDirty()} flag whenever we modify an object offset, and we reset it whenever we
 * open the connection; we reset the status bitfield data member after calling the parent
 * constructor.
 *
 * This object represents the building block for all concrete instances that represent
 * servers, databases, data collections and caches.
 +
 + When parsing the data source name, using the {@link parse_url()} function,, this class
 * will perform the following associations:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;scheme&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_PROTOCOL}&lt;/tt&gt;. This corresponds to the server
 *		and database protocols, which must be the same.
 *	&lt;li&gt;&lt;tt&gt;host&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_HOST}&lt;/tt&gt;. This corresponds to the server
 *		object connection host.
 *	&lt;li&gt;&lt;tt&gt;port&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_PORT}&lt;/tt&gt;. This corresponds to the server
 *		object connection port.
 *	&lt;li&gt;&lt;tt&gt;user&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_USER}&lt;/tt&gt;. This corresponds to the server
 *		object connection user code.
 *	&lt;li&gt;&lt;tt&gt;pass&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_PASS}&lt;/tt&gt;. This corresponds to the server
 *		object connection user password.
 *	&lt;li&gt;&lt;tt&gt;path&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_BASE}&lt;/tt&gt;. This corresponds to the database
 *		object name.
 *	&lt;li&gt;&lt;tt&gt;fragment&lt;/tt&gt;: &lt;tt&gt;{@link kTAG_CONN_COLL}&lt;/tt&gt;. This corresponds to the
 *		collection object name.
 * &lt;/ul&gt;
 *
 * The above associations are stored in the object's offsets, which means that a collection
 * will hold its database name and all the parameters of the server connection.
 *
 *	@author		Milko A. &Scaron;kofiƒç &lt;m.skofic@cgiar.org&gt;
 *	@version	1.00 16/01/2014
 */
abstract class ConnectionObject extends OntologyObject
{
	/**
	 * Status trait.
	 *
	 * In this class we handle the {@link isDirtyFlag()}
	 */
	use	traits\Status;

	/**
	 * Data source name.
	 *
	 * This data member holds the &lt;i&gt;data source name&lt;/i&gt;, or &lt;tt&gt;DSN&lt;/tt&gt;, it is an URL
	 * connection string that should be compatible with the {@link parse_url()} function.
	 * This string should hold all the connection parameters.
	 *
	 * @var string
	 */
	protected $mDSN = NULL;

	/**
	 * Parent connection.
	 *
	 * This data member holds the &lt;i&gt;parent connection object&lt;/i&gt;, this value should be an
	 * instance derived from this class which is used to instantiate the current object's
	 * connection resource.
	 *
	 * @var ConnectionObject
	 */
	protected $mParent = NULL;

	/**
	 * Connection resource.
	 *
	 * This data member holds the &lt;i&gt;connection resource&lt;/i&gt;, or &lt;i&gt;native connection&lt;/i&gt;,
	 * this property represents the actual connection resource.
	 *
	 * @var mixed
	 */
	protected $mConnection = NULL;

		

/*=======================================================================================
 *																						*
 *										MAGIC											*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	__construct																		*
	 *==================================================================================*/

	/**
	 * Instantiate class.
	 *
	 * The object may be instantiated as an empty object, by omitting both parameters; with
	 * a &lt;i&gt;data source name&lt;/i&gt; in the form of a connection URL; or by providing an array
	 * of tag/value parameters which will constitute the object's offsets.
	 *
	 * If you provide a data source name, this must be parsable by the {@link parse_url()}
	 * function, if this is not the case, you should use the parameters list.
	 *
	 * If the first parameter was provided, the method will synchronise both the data source
	 * name and the connection parameters.
	 *
	 * The second parameter represents the &lt;i&gt;connection parent&lt;/i&gt;, it must be an instance
	 * derived from this class and will only be set by the constructor.
	 *
	 * When overloading the constructor in derived classes you should always first call the
	 * parent method and then perform custom actions.
	 *
	 * @param mixed					$theParameter		Data source name or parameters.
	 * @param ConnectionObject		$theParent			Connection parent.
	 *
	 * @access public
	 *
	 * @throws Exception
	 *
	 * @uses DSN()
	 * @uses parseOffsets()
	 * @uses statusReset()
	 */
	public function __construct( $theParameter = NULL, $theParent = NULL )
	{
		//
		// Init object.
		//
		parent::__construct();
		
		//
		// Handle parameter.
		//
		if( $theParameter !== NULL )
		{
			//
			// Handle connection parameters.
			//
			if( is_array( $theParameter ) )
			{
				//
				// Load parameters.
				//
				foreach( $theParameter as $key =&gt; $value )
					$this-&gt;offsetSet( $key, $value );
				
				//
				// Generate and load DSN.
				//
				$this-&gt;DSN( $this-&gt;parseOffsets( $this-&gt;getArrayCopy() ), FALSE, FALSE );
			
			} // Provided individual parameters.
		
			//
			// Handle data source name.
			//
			else
				$this-&gt;DSN( (string) $theParameter );
		
		} // Provided parameter.
		
		//
		// Handle parent.
		//
		if( $theParent !== NULL )
		{
			//
			// Check type.
			//
			if( ! ($theParent instanceof self) )
				throw new \Exception(
					&quot;Invalid connection parent type.&quot; );						// !@! ==&gt;
			
			//
			// Set parent.
			//
			$this-&gt;mParent = $theParent;
		
		} // Provided parent.
		
		//
		// Reset status.
		//
		$this-&gt;statusReset();

	} // Constructor.

	 
	/*===================================================================================
	 *	__destruct																		*
	 *==================================================================================*/

	/**
	 * Destruct instance.
	 *
	 * The destructor will close the connection if open.
	 *
	 * @access public
	 *
	 * @uses closeConnection()
	 */
	public function __destruct()							{	$this-&gt;closeConnection();	}

		
	/*===================================================================================
	 *	__sleep																			*
	 *==================================================================================*/

	/**
	 * Sleep
	 *
	 * This method will close the connection and replace the connection resource with
	 * &lt;tt&gt;TRUE&lt;/tt&gt; if the connection was open.
	 *
	 * @access public
	 *
	 * @uses isConnected()
	 * @uses closeConnection()
	 */
	public function __sleep()
	{
		//
		// Check current connection.
		//
		if( $this-&gt;isConnected() )
		{
			//
			// Close connection.
			//
			$this-&gt;closeConnection();
			
			//
			// Mark as open.
			//
			$this-&gt;mConnection = TRUE;
		
		} // Connection is open.
		
		//
		// Reset connection.
		//
		else
			$this-&gt;mConnection = FALSE;
		
	} // __sleep.

	 
	/*===================================================================================
	 *	__wakeup																		*
	 *==================================================================================*/

	/**
	 * Wake up
	 *
	 * This method will re-open the connection if it was closed by the {@link __sleep()}
	 * method.
	 *
	 * @access public
	 *
	 * @uses openConnection()
	 */
	public function __wakeup()
	{
		//
		// Open closed connection.
		//
		if( $this-&gt;mConnection === TRUE )
			$this-&gt;openConnection();
		
	} // __wakeup.

	 
	/*===================================================================================
	 *	__toString																		*
	 *==================================================================================*/

	/**
	 * &lt;h4&gt;Return connection name&lt;/h4&gt;
	 *
	 * In this class we consider the data source name as the global identifier; here we
	 * return it as is, in derived classes you should be careful to shadow sensitive data.
	 *
	 * Note that this method cannot return the &lt;tt&gt;NULL&lt;/tt&gt; value, which means that it
	 * cannot be used until there is a data source name for the object.
	 *
	 * @access public
	 * @return string				The global identifier.
	 */
	public function __toString()								{	return $this-&gt;DSN();	}

		

/*=======================================================================================
 *																						*
 *							PUBLIC MEMBER MANAGEMENT INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	DSN																				*
	 *==================================================================================*/

	/**
	 * Manage data source name
	 *
	 * This method can be used to manage the &lt;i&gt;data source name&lt;/i&gt;, it accepts a parameter
	 * which represents either the data source name or the requested operation, depending on
	 * its value:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;NULL&lt;/tt&gt;: Return the current value.
	 *	&lt;li&gt;&lt;tt&gt;FALSE&lt;/tt&gt;: Delete the current value.
	 *	&lt;li&gt;&lt;i&gt;other&lt;/i&gt;: Set the value with the provided parameter.
	 * &lt;/ul&gt;
	 *
	 * The second parameter is a boolean which if &lt;tt&gt;TRUE&lt;/tt&gt; will return the &lt;i&gt;old&lt;/i&gt;
	 * value when replacing or resetting; if &lt;tt&gt;FALSE&lt;/tt&gt;, it will return the current
	 * value.
	 *
	 * The last parameter is a switch that determines whether the object offsets should be
	 * synchronised: if &lt;tt&gt;TRUE&lt;/tt&gt;, the object offsets will be reset and populated with
	 * the elements parsed from the data source name; if &lt;tt&gt;FALSE&lt;/tt&gt;, the object offsets
	 * will not be modified. This parameter is set to &lt;tt&gt;FALSE&lt;/tt&gt; by the constructor,
	 * since using all offsets may produce an invalid URL and is &lt;tt&gt;TRUE&lt;/tt&gt; by default,
	 * since setting a connection URL generally means changing the parameters.
	 *
	 * Whenever a new value is set or the value is deleted, the method will synchronise the
	 * object offsets.
	 *
	 * @param mixed					$theValue			Data source name or operation.
	 * @param boolean				$getOld				&lt;tt&gt;TRUE&lt;/tt&gt; get old value.
	 * @param boolean				$doSync				&lt;tt&gt;TRUE&lt;/tt&gt; will sync offsets.
	 *
	 * @access public
	 * @return mixed				&lt;i&gt;New&lt;/i&gt; or &lt;i&gt;old&lt;/i&gt; data source name.
	 *
	 * @throws Exception
	 *
	 * @see $mDSN
	 *
	 * @uses isConnected()
	 * @uses manageProperty()
	 * @uses parseDSN()
	 * @uses isDirty()
	 */
	public function DSN( $theValue = NULL, $getOld = FALSE, $doSync = TRUE )
	{
		//
		// Handle locked object.
		//
		if( $this-&gt;isConnected()
		 &amp;&amp; ($theValue !== NULL) )
			throw new \Exception(
				&quot;Unable to set data source: the connection is open.&quot; );			// !@! ==&gt;
		
		//
		// Manage property.
		//
		$save = $this-&gt;manageProperty( $this-&gt;mDSN, $theValue, $getOld );
		
		//
		// Handle value change.
		//
		if( $theValue !== NULL )
		{
			//
			// Sync offsets.
			//
			if( $doSync )
				$this-&gt;parseDSN( $this-&gt;mDSN );
			
			//
			// Handle dirty flag.
			//
			$this-&gt;isDirty( ! $doSync );
		}
		
		return $save;																// ==&gt;
	
	} // DSN.

		
	/*===================================================================================
	 *	Connection																		*
	 *==================================================================================*/

	/**
	 * Return connection resource.
	 *
	 * This method can be used to retrieve the &lt;i&gt;connection resource&lt;/i&gt;, this method is
	 * read-only, since the connection resource should only be set by the object's
	 * connection methods.
	 *
	 * The connection resource represents the native connection.
	 *
	 * @access public
	 * @return mixed				Connection resource.
	 *
	 * @see $mConnection
	 */
	public function Connection()							{	return $this-&gt;mConnection;	}

	 
	/*===================================================================================
	 *	Parent																			*
	 *==================================================================================*/

	/**
	 * Return connection parent.
	 *
	 * This method can be used to retrieve the &lt;i&gt;parent connection&lt;/i&gt;, this method is
	 * read-only, since the connection parent can only be set by the constructor and cannot
	 * be changed once the object has been instantiated.
	 *
	 * The connection parent represents the connection creator as the server for a database.
	 *
	 * @access public
	 * @return ConnectionObject		Parent connection.
	 *
	 * @see $mParent
	 */
	public function Parent()									{	return $this-&gt;mParent;	}

		

/*=======================================================================================
 *																						*
 *							PUBLIC CONNECTION MANAGEMENT INTERFACE						*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	isConnected																		*
	 *==================================================================================*/

	/**
	 * Check if connection is open
	 *
	 * This method returns a boolean flag indicating whether the connection is open or not.
	 *
	 * @access public
	 * @return boolean				&lt;tt&gt;TRUE&lt;/tt&gt; is open.
	 */
	public function isConnected()
	{
		return ( ($this-&gt;mConnection !== NULL)
			  &amp;&amp; ($this-&gt;mConnection !== TRUE) );									// ==&gt;
	
	} // isConnected.

		
	/*===================================================================================
	 *	openConnection																	*
	 *==================================================================================*/

	/**
	 * Open connection
	 *
	 * This method can be used to create and open the connection.
	 *
	 * We first check if the connection is already set: if so we do nothing.
	 *
	 * We call the protected {@link connectionOpen()} method which will open the connection
	 * and return the connection resource which will be set in the data member,
	 * {@link mConnection}.
	 *
	 * The method will return the connection resource.
	 *
	 * @access public
	 * @return mixed				Depends on implementation.
	 *
	 * @uses isConnected()
	 * @uses isDirty()
	 * @uses DSN()
	 * @uses parseOffsets()
	 * @uses connectionOpen()
	 */
	public function openConnection()
	{
		//
		// Check connection.
		//
		if( ! $this-&gt;isConnected() )
		{
			//
			// Synchronise DSN.
			//
			if( $this-&gt;isDirty() )
				$this-&gt;DSN( $this-&gt;parseOffsets( $this-&gt;getArrayCopy() ), FALSE, FALSE );
		
			//
			// Open and set connection.
			//
			$this-&gt;connectionOpen();
		
			//
			// Reset dirty flag.
			//
			$this-&gt;isDirty( FALSE );
		
		} // Not connected.
		
		return $this-&gt;mConnection;													// ==&gt;
	
	} // openConnection.

	 
	/*===================================================================================
	 *	closeConnection																	*
	 *==================================================================================*/

	/**
	 * Close connection
	 *
	 * If the connection is open, this method will close the connection and reset the
	 * {@link Connection} data member.
	 *
	 * The method will return &lt;tt&gt;TRUE&lt;/tt&gt; if the connection was open and &lt;tt&gt;FALSE&lt;/tt&gt; if
	 * not.
	 *
	 * @access public
	 * @return boolean				&lt;tt&gt;TRUE&lt;/tt&gt; if closed, &lt;tt&gt;FALSE&lt;/tt&gt; if was closed.
	 *
	 * @uses isConnected()
	 * @uses connectionClose()
	 */
	public function closeConnection()
	{
		//
		// Check connection.
		//
		if( $this-&gt;isConnected() )
		{
			//
			// Close connection.
			//
			$this-&gt;connectionClose();
			
			//
			// Reset connection.
			//
			$this-&gt;mConnection = NULL;
			
			return TRUE;															// ==&gt;
		
		} // Was open.
		
		return FALSE;																// ==&gt;
	
	} // closeConnection.

	 

/*=======================================================================================
 *																						*
 *								PROTECTED CONNECTION INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	connectionOpen																	*
	 *==================================================================================*/

	/**
	 * Open connection
	 *
	 * This method should open the actual connection and set the {@link mConnection} data
	 * member; in this class the method is virtual.
	 *
	 * This method expects the caller to have checked whether the connection is already
	 * open.
	 *
	 * If the operation fails, the method should raise an exception.
	 *
	 * @access protected
	 * @return mixed				The native connection.
	 */
	abstract protected function connectionOpen();

	 
	/*===================================================================================
	 *	connectionClose																	*
	 *==================================================================================*/

	/**
	 * Open connection
	 *
	 * This method should close the actual connection, in this class the method is virtual.
	 *
	 * This method expects the caller to have checked whether the connection is open.
	 *
	 * If the operation fails, the method should raise an exception.
	 *
	 * @param mixed					$theConnection		Connection.
	 *
	 * @access protected
	 */
	abstract protected function connectionClose();

		

/*=======================================================================================
 *																						*
 *								PROTECTED PARSING INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	parseDSN																		*
	 *==================================================================================*/

	/**
	 * Parse data source name
	 *
	 * This method will parse the provided data source name, extract the connection
	 * parameters and set them in the current object.
	 *
	 * The method will make use of the {@link parse_url()} function and pass each key/value
	 * pair to the protected {@link loadDSNParameter()} method which has the responsibility
	 * of matching the {@link parse_url()} keys to {@link Tag} instances.
	 *
	 * If the {@link parse_url()} function fails to parse the DSN, the method will raise an
	 * exception.
	 *
	 * Derived classes should overload the {@link loadDSNParameter()} method.
	 *
	 * @param string				$theDSN				Data source name.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @uses loadDSNParameter()
	 */
	protected function parseDSN( $theDSN )
	{
		//
		// Reset parameters.
		//
		$empty = Array();
		$this-&gt;exchangeArray( $empty );
		
		//
		// Check if set.
		//
		if( strlen( $theDSN ) )
		{
			//
			// Parse DSN.
			//
			$encoded = parse_url( $theDSN );
			if( $encoded === FALSE )
				throw new \Exception(
					&quot;Invalid connection string [$dsn].&quot; );						// !@! ==&gt;
			
			//
			// Load parameters.
			//
			foreach( $encoded as $key =&gt; $value )
				$this-&gt;loadDSNParameter( $encoded, $key, $value );
		
		} // Has DSN.
	
	} // parseDSN.

	 
	/*===================================================================================
	 *	parseOffsets																	*
	 *==================================================================================*/

	/**
	 * Parse connection parameters
	 *
	 * This method will parse the provided key/value array and generate a connection URL.
	 *
	 * The method will iterate the provided offsets and feed them to the protected
	 * {@link parseOffset()} method which will populate an array structured as the result of
	 * the {@link parse_url()} function, it will be the duty of this method to generate a
	 * data source name from that array.
	 *
	 * Derived classes should overload the called methods and not this one.
	 *
	 * If the resulting data source name is empty, the method will return &lt;tt&gt;FALSE&lt;/tt&gt;.
	 *
	 * @param array					$theOffsets			Offsets.
	 *
	 * @access protected
	 * @return mixed				Data source name or &lt;tt&gt;FALSE&lt;/tt&gt; if empty.
	 *
	 * @uses parseOffset()
	 */
	protected function parseOffsets( $theOffsets )
	{
		//
		// Init local storage.
		//
		$params = Array();
		
		//
		// Iterate offsets.
		//
		foreach( $theOffsets as $key =&gt; $value )
			$this-&gt;parseOffset( $params, $key, $value );
		
		//
		// Handle parameters.
		//
		if( count( $params ) )
		{
			//
			// Init local storage.
			//
			$dsn = '';
			
			//
			// Set protocol.
			//
			if( array_key_exists( 'scheme', $params ) )
				$dsn .= $params[ 'scheme' ].'://';
		
			//
			// Handle credentials.
			//
			if( array_key_exists( 'user', $params ) )
			{
				//
				// Set user.
				//
				$dsn .= $params[ 'user' ];
			
				//
				// Set password.
				//
				if( array_key_exists( 'pass', $params ) )
					$dsn .= (':'.$params[ 'pass' ]);
			
				//
				// Close credentials.
				//
				$dsn .= '@';
		
			} // Has user.
		
			//
			// Add host.
			//
			if( array_key_exists( 'host', $params ) )
				$dsn .= $params[ 'host' ];
		
			//
			// Add port.
			//
			if( array_key_exists( 'port', $params ) )
				$dsn .= (':'.$params[ 'port' ]);
		
			//
			// Handle path.
			// Note that we add a leading slash
			// if the parameter does not start with one.
			//
			if( array_key_exists( 'path', $params ) )
			{
				if( ! (substr( $params[ 'path' ], 0, 1 ) == '/') )
					$dsn .= '/';
				$dsn .= $params[ 'path' ];
			}
		
			//
			// Set options.
			//
			if( array_key_exists( 'query', $params ) )
				$dsn .= ('?'.$params[ 'query' ]);
		
			//
			// Set fragments.
			//
			if( array_key_exists( 'fragment', $params ) )
				$dsn .= ('#'.$params[ 'fragment' ]);
		
			return $dsn;															// ==&gt;
		
		} // Has parameters.
		
		return FALSE;																// ==&gt;
		
	} // parseOffsets.

	 
	/*===================================================================================
	 *	parseOffset																		*
	 *==================================================================================*/

	/**
	 * Parse offset
	 *
	 * This method will parse the provided offset and populate the provided parameters.
	 * The main duty is to load the offset values into the provided parameters array so to
	 * create the same result as the {@link parse_url()} function.
	 *
	 * The resulting array can have the following elements:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/tt&gt;: The protocol or scheme.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;host&lt;/code&gt;&lt;/tt&gt;: The connection host.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;port&lt;/code&gt;&lt;/tt&gt;: The connection port.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;user&lt;/code&gt;&lt;/tt&gt;: The user code.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;pass&lt;/code&gt;&lt;/tt&gt;: The user password.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;path&lt;/code&gt;&lt;/tt&gt;: The connection path.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;query&lt;/code&gt;&lt;/tt&gt;: The connection options.
	 *	&lt;li&gt;&lt;tt&gt;&lt;code&gt;fragment&lt;/code&gt;&lt;/tt&gt;: The URL fragment.
	 * &lt;/ul&gt;
	 *
	 * In this class we handle the following offsets:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_PROTOCOL}&lt;/tt&gt;: The &lt;code&gt;scheme&lt;/code&gt;.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_HOST}&lt;/tt&gt;: The connection &lt;code&gt;host&lt;/code&gt;.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_PORT}&lt;/tt&gt;: The connection &lt;code&gt;port&lt;/code&gt;.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_USER}&lt;/tt&gt;: The &lt;code&gt;user&lt;/code&gt; code.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_PASS}&lt;/tt&gt;: The user &lt;code&gt;pass&lt;/code&gt;word.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_BASE}&lt;/tt&gt;: The user &lt;code&gt;path&lt;/code&gt;word.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_COLL}&lt;/tt&gt;: The user &lt;code&gt;fragment&lt;/code&gt;word.
	 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_CONN_OPTS}&lt;/tt&gt;: The connection options, &lt;code&gt;query&lt;/code&gt;.
	 * &lt;/ul&gt;
	 *
	 * Derived classes can overload this method to customise the parameters.
	 *
	 * @param reference				$theParameters		Receives parsed offset.
	 * @param string				$theOffset			Offset.
	 * @param mixed					$theValue			Offset value.
	 *
	 * @access protected
	 *
	 * @uses parseOption()
	 */
	protected function parseOffset( &amp;$theParameters, $theOffset, $theValue )
	{
		//
		// Parse by tag.
		//
		switch( $theOffset )
		{
			case kTAG_CONN_PROTOCOL:
				$theParameters[ 'scheme' ] = $theValue;
				break;
			
			case kTAG_CONN_HOST:
				$theParameters[ 'host' ] = $theValue;
				break;
			
			case kTAG_CONN_PORT:
				$theParameters[ 'port' ] = $theValue;
				break;
			
			case kTAG_CONN_USER:
				$theParameters[ 'user' ] = $theValue;
				break;
			
			case kTAG_CONN_PASS:
				$theParameters[ 'pass' ] = $theValue;
				break;
			
			case kTAG_CONN_BASE:
				$theParameters[ 'path' ] = $theValue;
				break;
			
			case kTAG_CONN_COLL:
				$theParameters[ 'fragment' ] = $theValue;
				break;
			
			case kTAG_CONN_OPTS:
				$options = $this-&gt;offsetGet( kTAG_CONN_OPTS );
				foreach( $options as $key =&gt; $value )
					$this-&gt;parseOption( $theParameters, $key, $value );
				break;
		}
		
	} // parseOffset.

	 
	/*===================================================================================
	 *	parseOption																		*
	 *==================================================================================*/

	/**
	 * Parse option
	 *
	 * This method will parse the provided option and populate the query parameters.
	 * The main duty is to load the option into the &lt;code&gt;query&lt;/code&gt; element of the
	 * provided parameters list as the result of the {@link parse_url()} function.
	 *
	 * In this class we load what we find.
	 *
	 * Derived classes can overload this method to customise the options.
	 *
	 * @param reference				$theParameters		Receives parsed offset.
	 * @param string				$theOption			Option.
	 * @param mixed					$theValue			Option value.
	 *
	 * @access protected
	 */
	protected function parseOption( &amp;$theParameters, $theOption, $theValue )
	{
		//
		// Add divider.
		//
		if( array_key_exists( 'query', $theParameters ) )
			$theParameters[ 'query' ] .= '&amp;';
		
		//
		// Create element.
		//
		else
			$theParameters[ 'query' ] = '';
		
		//
		// Set option.
		//
		$theParameters[ 'query' ] .= $theOption;
		if( $theValue !== NULL )
			$theParameters[ 'query' ] .= ('='.$theValue);
		
	} // parseOption.

		

/*=======================================================================================
 *																						*
 *							PROTECTED PARAMETER LOADING INTERFACE						*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	loadDSNParameter																*
	 *==================================================================================*/

	/**
	 * Load connection parameters from DSN
	 *
	 * This method will load the parameters parsed from the data source name into the
	 * current object's offsets, it expects three parameters:
	 *
	 * &lt;ul&gt;
	 *	&lt;li&gt;&lt;b&gt;$theParameters&lt;/b&gt;: This array is the result of the {@link parse_url()}
	 *		function on the data source name:
	 *	 &lt;ul&gt;
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_PROTOCOL}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;host&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_HOST}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;port&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_PORT}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;user&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_USER}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;pass&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_PASS}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;path&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_BASE}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;fragment&lt;/code&gt;&lt;/tt&gt;: We set it in {@link kTAG_CONN_COLL}.
	 *		&lt;li&gt;&lt;tt&gt;&lt;code&gt;query&lt;/code&gt;&lt;/tt&gt;: We load the key/value pairs into
	 *			{@link kTAG_CONN_OPTS} array.
	 *	 &lt;/ul&gt;
	 *	&lt;li&gt;&lt;b&gt;$theKey&lt;/b&gt;: This parameter represents the offset.
	 *	&lt;li&gt;&lt;b&gt;$theValue&lt;/b&gt;: This parameter represents the offset value.
	 * &lt;/ul&gt;
	 *
	 * This is the method that derived classes may overload to customise the parameters.
	 *
	 * @param reference				$theParameters		Original parameters list.
	 * @param string				$theKey				Parameter key.
	 * @param string				$theValue			Parameter value.
	 *
	 * @access protected
	 */
	protected function loadDSNParameter( &amp;$theParameters, $theKey, $theValue = NULL )
	{
		//
		// Parse parameter.
		//
		switch( $theKey )
		{
			case 'scheme':
				$this-&gt;offsetSet( kTAG_CONN_PROTOCOL, $theValue );
				break;
			
			case 'host':
				$this-&gt;offsetSet( kTAG_CONN_HOST, $theValue );
				break;
			
			case 'port':
				$this-&gt;offsetSet( kTAG_CONN_PORT, (int) $theValue );
				break;
			
			case 'user':
				$this-&gt;offsetSet( kTAG_CONN_USER, $theValue );
				break;
			
			case 'pass':
				$this-&gt;offsetSet( kTAG_CONN_PASS, $theValue );
				break;
			
			case 'path':
				if( substr( $theValue, 0, 1 ) == '/' )
					$theValue = substr( $theValue, 1 );
				$this-&gt;offsetSet( kTAG_CONN_BASE, $theValue );
				break;
			
			case 'fragment':
				$this-&gt;offsetSet( kTAG_CONN_COLL, $theValue );
				break;
			
			case 'query':
				$options = Array();
				$opts = explode( '&amp;', $theValue );
				foreach( $opts as $opt )
				{
					$tmp = explode( '=', $opt );
					$key = trim( $tmp[ 0 ] );
					if( count( $tmp ) &gt; 1 )
						$options[ $key ]
							= ( strlen( $tmp[ 1 ] ) )
							? $tmp[ 1 ]
							: NULL;
					else
						$options[ $key ] = NULL;
			
				}
				$this-&gt;offsetSet( kTAG_CONN_OPTS, $options );
				break;
		}
	
	} // loadDSNParameter.

		

/*=======================================================================================
 *																						*
 *							PROTECTED ARRAY ACCESS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before setting it
	 *
	 * We overload this method to prevent setting values while the connection is open.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 * @return mixed				&lt;tt&gt;NULL&lt;/tt&gt; set offset value, other, return.
	 *
	 * @throws Exception
	 *
	 * @uses isConnected()
	 */
	protected function preOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Check if connected.
		//
		if( $this-&gt;isConnected() )
			throw new \Exception(
				&quot;Cannot set value: the connection is open.&quot; );					// !@! ==&gt;
		
		return parent::preOffsetSet( $theOffset, $theValue );						// ==&gt;
	
	} // preOffsetSet.

	 
	/*===================================================================================
	 *	postOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value after setting it
	 *
	 * We set the {@link isDirty()} status.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 *
	 * @uses isDirty()
	 */
	protected function postOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Call parent method.
		//
		parent::postOffsetSet( $theOffset, $theValue );
		
		//
		// Set dirty status.
		//
		$this-&gt;isDirty( TRUE );
	
	} // postOffsetSet.

	 
	/*===================================================================================
	 *	preOffsetUnset																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before deleting it
	 *
	 * We overload this method to prevent deleting values while the connection is open.
	 *
	 * @param reference				$theOffset			Offset reference.
	 *
	 * @access protected
	 * @return mixed				&lt;tt&gt;NULL&lt;/tt&gt; delete offset value, other, return.
	 *
	 * @uses isConnected()
	 */
	protected function preOffsetUnset( &amp;$theOffset )
	{
		//
		// Check if connected.
		//
		if( $this-&gt;isConnected() )
			throw new \Exception(
				&quot;Cannot delete value: the connection is open.&quot; );				// !@! ==&gt;
		
		return parent::preOffsetUnset( $theOffset );								// ==&gt;
	
	} // preOffsetUnset.

	 
	/*===================================================================================
	 *	postOffsetUnset																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value after deleting it
	 *
	 * We set the {@link isDirty()} status.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 *
	 * @uses isDirty()
	 */
	protected function postOffsetUnset( &amp;$theOffset )
	{
		//
		// Call parent method.
		//
		parent::postOffsetUnset( $theOffset );
		
		//
		// Set dirty status.
		//
		$this-&gt;isDirty( TRUE );
	
	} // postOffsetSet.

	 

} // class ConnectionObject.


?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>