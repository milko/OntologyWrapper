<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * Node.php
 *
 * This file contains the definition of the {@link Node} class.
 */

namespace OntologyWrapper;

use OntologyWrapper\PersistentObject;
use OntologyWrapper\Tag;
use OntologyWrapper\Term;
use OntologyWrapper\ServerObject;
use OntologyWrapper\DatabaseObject;
use OntologyWrapper\CollectionObject;

/*=======================================================================================
 *																						*
 *										Node.php										*
 *																						*
 *======================================================================================*/

/**
 * Node
 *
 * A node is a &lt;em&gt;vertex in a graph structure&lt;/em&gt;, nodes reference
 * &lt;em&gt;{@link Term}&lt;/em&gt; and &lt;em&gt;{@link Tag&lt;/em&gt; instances, when referencing a
 * term, nodes are used to build &lt;em&gt;ontologies&lt;/em&gt;, &lt;em&gt;type definitions&lt;/em&gt; and
 * &lt;em&gt;controlloed vocabularies&lt;/em&gt;; when referencing tags they are used to build &lt;em&gt;data
 * structures&lt;/em&gt;, &lt;em&gt;input and output templates&lt;/em&gt; and &lt;em&gt;search forms&lt;/em&gt;.
 *
 * Node objects, along with edge objects, represent the presentation layer of the ontology,
 * users compose and consult network structures through these objects.
 *
 * The class features the following default offsets:
 *
 * &lt;ul&gt;
 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_NID}&lt;/tt&gt;: &lt;em&gt;Native identifier&lt;/em&gt;. This required attribute holds
 *		an &lt;em&gt;integer serial number&lt;/em&gt;, nodes do not have a unique persistent identifier,
 *		since they act as references and because you may have more than one node referencing
 *		the same term or property. The native identifier is assigned automatically.
 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_TERM}&lt;/tt&gt;: &lt;em&gt;Term&lt;/em&gt;. This attribute is a &lt;em&gt;string&lt;/em&gt; that
 *		holds a reference to the &lt;em&gt;term object&lt;/em&gt; that the current node &lt;em&gt;represents
 *		in a graph structure&lt;/em&gt;. If this offset is set, the {@link kTAG_TAG} offset must
 *		be omitted. This attribute must be managed with its offset.
 *	&lt;li&gt;&lt;tt&gt;{@link kTAG_TAG}&lt;/tt&gt;: &lt;em&gt;Tag&lt;/em&gt;. This attribute is a &lt;em&gt;string&lt;/em&gt; that
 *		holds a reference to the &lt;em&gt;tag object&lt;/em&gt; that the current node &lt;em&gt;represents
 *		in a graph structure&lt;/em&gt;. If this offset is set, the {@link kTAG_TERM} offset must
 *		be omitted. This attribute must be managed with its offset.
 * &lt;/ul&gt;
 *
 * The {@link __toString()} method will return the value stored in the {@link kTAG_TERM} or
 * the {@link kTAG_TAG} offset. This value represents the node persistent identifier, which
 * is not, however, unique.
 *
 * Nodes cannot be uniquely identified via a persistent identifier, because more than one
 * node may share the same term or tag, this means that when searching for nodes you should
 * rely more on traversing a graph path, rather than selecting an object from a list.
 *
 * Objects of this class can hold any additional attribute that is considered necessary or
 * useful to define and share the current node. In this class we define only those
 * attributes that constitute the core functionality of the object, derived classes will add
 * attributes specific to the domain in which the object will operate.
 *
 * The object is considered initialised, {@link isInited()}, if it has at least the term
 * reference, {@link kTAG_TERM}, or the tag reference, {@link kTAG_TAG}.
 *
 *	@author		Milko A. &Scaron;kofiƒç &lt;m.skofic@cgiar.org&gt;
 *	@version	1.00 07/02/2014
 */
class Node extends PersistentObject
{
	/**
	 * Default collection name.
	 *
	 * This constant provides the &lt;i&gt;default collection name&lt;/i&gt; in which objects of this
	 * class are stored.
	 *
	 * @var string
	 */
	const kSEQ_NAME = '_nodes';

		

/*=======================================================================================
 *																						*
 *										MAGIC											*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	__construct																		*
	 *==================================================================================*/

	/**
	 * Instantiate class.
	 *
	 * In this class we link the inited status with the presence of the tag or the term.
	 *
	 * @param ConnectionObject		$theContainer		Persistent store.
	 * @param mixed					$theIdentifier		Object identifier.
	 *
	 * @access public
	 *
	 * @see kTAG_TAG kTAG_TERM
	 *
	 * @uses isInited()
	 */
	public function __construct( $theContainer = NULL, $theIdentifier = NULL )
	{
		//
		// Load object with contents.
		//
		parent::__construct( $theContainer, $theIdentifier );
		
		//
		// Set initialised status.
		//
		$this-&gt;isInited( \ArrayObject::offsetExists( kTAG_TAG ) ||
						 \ArrayObject::offsetExists( kTAG_TERM ) );

	} // Constructor.

	 
	/*===================================================================================
	 *	__toString																		*
	 *==================================================================================*/

	/**
	 * &lt;h4&gt;Return global identifier&lt;/h4&gt;
	 *
	 * If the object holds the term reference, this will be returned; if it holds the tag
	 * reference, it will be returned; if none of these are set, the method will return an
	 * empty string.
	 *
	 * @access public
	 * @return string				The persistent identifier.
	 */
	public function __toString()
	{
		//
		// Get term.
		//
		if( \ArrayObject::offsetExists( kTAG_TERM ) )
			return \ArrayObject::offsetGet( kTAG_TERM );							// ==&gt;
		
		//
		// Get tag.
		//
		if( \ArrayObject::offsetExists( kTAG_TAG ) )
			return \ArrayObject::offsetGet( kTAG_TAG );								// ==&gt;
		
		return '';																	// ==&gt;
	
	} // __toString.

		

/*=======================================================================================
 *																						*
 *								STATIC CONNECTION INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	ResolveDatabase																	*
	 *==================================================================================*/

	/**
	 * Resolve the database
	 *
	 * In this class we return the metadata database.
	 *
	 * @param Wrapper				$theWrapper			Wrapper.
	 * @param boolean				$doAssert			Raise exception if unable.
	 * @param boolean				$doOpen				&lt;tt&gt;TRUE&lt;/tt&gt; open connection.
	 *
	 * @static
	 * @return DatabaseObject		Database or &lt;tt&gt;NULL&lt;/tt&gt;.
	 *
	 * @throws Exception
	 */
	static function ResolveDatabase( Wrapper $theWrapper, $doAssert = TRUE, $doOpen = TRUE )
	{
		//
		// Get metadata database.
		//
		$database = $theWrapper-&gt;Metadata();
		if( $database instanceof DatabaseObject )
		{
			//
			// Open connection.
			//
			if( $doOpen )
				$database-&gt;openConnection();
			
			return $database;														// ==&gt;
		
		} // Retrieved metadata database.
		
		//
		// Raise exception.
		//
		if( $doAssert )
			throw new \Exception(
				&quot;Unable to resolve database: &quot;
			   .&quot;missing metadata reference in wrapper.&quot; );						// !@! ==&gt;
		
		return NULL;																// ==&gt;
	
	} // ResolveDatabase.

		

/*=======================================================================================
 *																						*
 *								PROTECTED COMMIT INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preCommitIdentify																*
	 *==================================================================================*/

	/**
	 * Set object identifiers before commit
	 *
	 * In this class we set the native identifier with the sequence number.
	 *
	 * @access protected
	 */
	protected function preCommitIdentify()
	{
		//
		// Call parent method.
		//
		parent::preCommitIdentify();
		
		//
		// Resolve collection.
		//
		$collection
			= static::ResolveCollection(
				static::ResolveDatabase( $this-&gt;mDictionary, TRUE ) );
		
		//
		// Set sequence number.
		//
		if( ! \ArrayObject::offsetExists( kTAG_NID ) )
			$this-&gt;offsetSet(
				kTAG_NID,
				$collection-&gt;getSequenceNumber(
					static::kSEQ_NAME ) );
	
	} // preCommitIdentify.

		

/*=======================================================================================
 *																						*
 *								PROTECTED STATUS INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	isReady																			*
	 *==================================================================================*/

	/**
	 * Check if object is ready
	 *
	 * In this class we ensure the object has the native identifier, {@link kTAG_NID}.
	 *
	 * @access protected
	 * @return Boolean				&lt;tt&gt;TRUE&lt;/tt&gt; means ready.
	 *
	 * @uses isReady()
	 * @uses isInited()
	 */
	protected function isReady()
	{
		return ( parent::isReady()
			  &amp;&amp; $this-&gt;offsetExists( kTAG_NID ) );									// ==&gt;
	
	} // isReady.

		

/*=======================================================================================
 *																						*
 *							PROTECTED ARRAY ACCESS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before setting it
	 *
	 * In this class we cast the value of the term into a term reference, or the value of a
	 * tag in a tag reference; we also ensure that provided objects are of the correct
	 * class.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 * @return mixed				&lt;tt&gt;NULL&lt;/tt&gt; set offset value, other, return.
	 *
	 * @throws Exception
	 *
	 * @see kTAG_TAG kTAG_TERM
	 */
	protected function preOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Call parent method to resolve offset.
		//
		$ok = parent::preOffsetSet( $theOffset, $theValue );
		if( $ok === NULL )
		{
			//
			// Intercept tag.
			//
			if( $theOffset == kTAG_TAG )
			{
				//
				// Handle objects.
				//
				if( is_object( $theValue ) )
				{
					//
					// If term, get its reference.
					//
					if( $theValue instanceof Tag )
						$theValue = $theValue-&gt;reference();
				
					//
					// If not a term, complain.
					//
					else
						throw new \Exception(
							&quot;Unable to set tag reference: &quot;
						   .&quot;provided an object other than a tag.&quot; );			// !@! ==&gt;
			
				} // Object.
			
				//
				// Cast to string.
				//
				else
					$theValue = (string) $theValue;
			
			} // Setting tag.
			
			//
			// Intercept term.
			//
			if( $theOffset == kTAG_TERM )
			{
				//
				// Handle objects.
				//
				if( is_object( $theValue ) )
				{
					//
					// If term, get its reference.
					//
					if( $theValue instanceof Term )
						$theValue = $theValue-&gt;reference();
				
					//
					// If not a term, complain.
					//
					else
						throw new \Exception(
							&quot;Unable to set term reference: &quot;
						   .&quot;provided an object other than a term.&quot; );			// !@! ==&gt;
			
				} // Object.
			
				//
				// Cast to string.
				//
				else
					$theValue = (string) $theValue;
			
			} // Setting term.
			
		} // Passed preflight.
		
		return $ok;																	// ==&gt;
	
	} // preOffsetSet.

	 
	/*===================================================================================
	 *	postOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value after setting it
	 *
	 * In this class we delete the tag when we set the term and vice-versa.
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 *
	 * @see kTAG_TAG kTAG_TERM
	 *
	 * @uses isInited()
	 */
	protected function postOffsetSet( &amp;$theOffset, &amp;$theValue )
	{
		//
		// Handle new tag.
		//
		if( $theOffset == kTAG_TAG )
			$this-&gt;offsetUnset( kTAG_TERM );
	
		//
		// Handle new term.
		//
		if( $theOffset == kTAG_TERM )
			$this-&gt;offsetUnset( kTAG_TAG );
	
		//
		// Set initialised status.
		//
		$this-&gt;isInited( \ArrayObject::offsetExists( kTAG_TAG ) ||
						 \ArrayObject::offsetExists( kTAG_TERM ) );
	
	} // postOffsetSet.

	 
	/*===================================================================================
	 *	postOffsetUnset																	*
	 *==================================================================================*/

	/**
	 * Handle offset after deleting it
	 *
	 * In this class we set the {@link isInited()} status.
	 *
	 * @param reference				$theOffset			Offset reference.
	 *
	 * @access protected
	 *
	 * @see kTAG_TAG kTAG_TERM
	 *
	 * @uses isInited()
	 */
	protected function postOffsetUnset( &amp;$theOffset )
	{
		//
		// Call parent method.
		//
		parent::postOffsetUnset( $theOffset );
		
		//
		// Set initialised status.
		//
		$this-&gt;isInited( \ArrayObject::offsetExists( kTAG_TAG ) ||
						 \ArrayObject::offsetExists( kTAG_TERM ) );
	
	} // postOffsetUnset.

		

/*=======================================================================================
 *																						*
 *							PROTECTED OFFSET STATUS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	lockedOffsets																	*
	 *==================================================================================*/

	/**
	 * Return list of locked offsets
	 *
	 * In this class we return the {@link kTAG_TAG} and the {@link kTAG_TERM} offsets.
	 *
	 * @access protected
	 * @return array				List of locked offsets.
	 *
	 * @see kTAG_TAG kTAG_TERM
	 */
	protected function lockedOffsets()
	{
		return array_merge( $this-&gt;InternalOffsets(),
							array( kTAG_TAG, kTAG_TERM ) );							// ==&gt;
	
	} // lockedOffsets.

	 

} // class Node.


?&gt;
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>