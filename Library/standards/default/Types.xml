<?xml version="1.0" encoding="UTF-8"?>
<!--
	DEFAULT TYPES
	Types.xml
-->
<METADATA
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:noNamespaceSchemaLocation="http://resources.grinfo.net/Schema/Dictionary.xsd">
	
	<!-- Primitive data types -->
	
	<META>
		<!-- kTYPE_MIXED -->
		<TERM ns=":type" lid="mixed">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Mixed</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>mixed</em> data type indicates that the referred property may take <em>any data type</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_STRING -->
		<TERM ns=":type" lid="string">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">String</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>string</em> data type indicates that the referred property may hold <em>UNICODE</em> characters, this type <em>does not include binary data</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_INT -->
		<TERM ns=":type" lid="int">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">String</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>integer</em> data type indicates that the referred property may hold a <em>32 or 64 bit integral numeric value</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_FLOAT -->
		<TERM ns=":type" lid="float">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Float</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>float</em> data type indicates that the referred property may hold a <em>floating point number</em>, also known as <em>double</em> or <em>real</em>. The precision of such value is not inferred, in general it will be a <em>32 or 64 bit real</em>.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Structured data types -->
	
	<META>
		<!-- kTYPE_STRUCT -->
		<TERM ns=":type" lid="struct">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Structure</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This data type defines a <em>structure</em>, this means that the value will be an <em>object</em> or an array of objects if the data kind is a list.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_ARRAY -->
		<TERM ns=":type" lid="array">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Array</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This data type defines a <em>list of key/value pairs</em>, the key will be in general a string, while the value type is not inferred. This data type usually applies to arrays in which the key part is the discriminant and determines the type of the value, while traditional arrays are better defined by a fixed sata type and a list data kind.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_LANGUAGE_STRINGS -->
		<TERM ns=":type" lid="language-strings">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Language strings</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This data type defines a <em>list of strings expressed in different languages</em>. The list elements are composed by two key/value pairs. The first pair has the tag corresponding to the <tt>:language</tt> persistent identifier as its key and the value represents the language code. The second pair has the tag corresponding to the <tt>:text</tt> persistent identifier as its key and the value represents the text expressed in the language defined in the first pair. No two elements may share the same language and only one element may omit the language pair.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_TYPED_LIST -->
		<TERM ns=":type" lid="typed-list">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Typed list</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This data type defines a <em>list of elements discriminated by their type</em>. The list elements are composed by two key/value pairs. The first pair has the tag corresponding to the <tt>:type</tt> persistent identifier as its key and the value represents the type of the element. The second pair has an unspecified tag persistent identifier which characterises the value of the element: the value of the first pair represents the type of the second pair value identified by the tag set in its key. No two elements may share the same type and only one element may omit the type pair.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_SHAPE -->
		<TERM ns=":type" lid="shape">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Shape</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This data type defines a <em>geometric shape</em>which is expressed as a GeoJSON construct, it is an array composed by two key/value elements:<ul><li><tt>type</tt>: The element indexed by this string contains the code indicating the type of the shape, these are the supported values:<ul><li><tt>Point</tt>: A point.<li><tt>LineString</tt>: A list of points.<li><tt>Polygon</tt>: A polygon, including its rings.</ul><li><tt>coordinates</tt>: The element indexed by this string contains the <em>geometry of the shape</em>, which has a structure depending on the shape type:<ul><li><tt>Point</tt>: The point is an array of two floating point numbers, respectively the <em>longitude</em> and <em>latitude</em>.<li><tt>LineString</tt>: A line string is an array of points expressed as the <tt>Point</tt> geometry.<li><tt>Polygon</tt>: A polygon is a list of rings whose geometry is like the <tt>LineString</em> geometry, except that the first and last point must match. The first ring represents the outer boundary of the polygon, the other rings are optional and represent holes in the polygon.</ul></ul>]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Standards data types -->
	
	<META>
		<!-- kTYPE_URL -->
		<TERM ns=":type" lid="url">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Link</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>link</em> data type indicates that the referred property is a <em>string</em> representing an <em>URL</em> which is an internet link or network address.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Enumerated data types -->
	
	<META>
		<!-- Enumeration -->
		<TERM ns=":type" lid="enum">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Enumeration</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>enumerated</em> data type indicates that the referred property may only hold <em>a term reference</em>, that is, the <em>global identifier of a term object</em>. Enumerated values are by default strings and must refer to a term.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Enumerated set -->
		<TERM ns=":type" lid="enum-set">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Enumerated set</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>enumerated set</em> data type indicates that the referred property may only hold <em>a list of term reference</em>, that is, an array of <em>term object global identifiers</em>. All the elements of this list must be unique.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Object reference data types -->
	
	<META>
		<!-- Term reference -->
		<TERM ns=":type:ref" lid="term">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Term reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <i>term reference</i> is a <em>string</em> that must correspond to the <em>native identifier of a Term object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Tag reference -->
		<TERM ns=":type:ref" lid="tag">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Tag reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <i>tag reference</i> is an <em>integer</em> that must correspond to the <em>sequence number of a Tag object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Node reference -->
		<TERM ns=":type:ref" lid="node">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Node reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <i>node reference</i> is an <em>integer</em> that must correspond to the <em>netive identifier of a Node object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Edge reference -->
		<TERM ns=":type:ref" lid="edge">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Edge reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <i>edge reference</i> is a <em>string</em> that must correspond to the <em>native identifier of an Edge object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Entity reference -->
		<TERM ns=":type:ref" lid="entity">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Entity reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <i>entity reference</i> is a <em>string</em> that must correspond to the <em>native identifier of an Entity object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Unit reference -->
		<TERM ns=":type:ref" lid="unit">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Unit reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <i>unit reference</i> is a <em>string</em> that must correspond to the <em>native identifier of a Unit object</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Self reference -->
		<TERM ns=":type:ref" lid="self">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Self reference</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <i>self reference</i> is a <em>reference to an object of the same class as the object that holds the reference</em>.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Cardinality types -->
	
	<META>
		<!-- List -->
		<TERM ns=":type" lid="list">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">List</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This kind indicates that the property is a <em>list of values</em>, each <em>of the defined data type</em>.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Private input -->
		<TERM ns=":type" lid="private-in">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Private input</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This kind indicates that the data property is <em>private in input</em>, which means that it is automatically managed by the class and should not be explicitly set by clients.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Private output -->
		<TERM ns=":type" lid="private-out">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Private output</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[This kind indicates that the data property is <em>private in output</em>, which means that it is internal and should not be displayed to clients.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Relationship types -->
	
	<META>
		<!-- Incoming -->
		<TERM ns=":relationship" lid="in">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Incoming</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>incoming relationship</em> indicates that the relationship is <em>originating</em> from an <em>external vertex</em> directed to the current vertex.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Outgoing -->
		<TERM ns=":relationship" lid="out">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Outgoing</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>outgoing relationship</em> indicates that the relationship is <em>originating</em> from the <em>current vertex</em> directed to an external vertex.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- Bi-directional -->
		<TERM ns=":relationship" lid="all">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Bi-directional</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>bi-directional relationship</em> indicates that it is <em>both incoming and outgoing</em>, it <em>originates</em> from both the <em>current and external</em> vertices.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Node types -->
	
	<META>
		<!-- kTYPE_NODE_ROOT -->
		<TERM ns=":type:node" lid="root">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Root</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>An entry point of a structure</em>. This kind represents a door or entry point of a tree or graph. It can be either the node from which the whole structure originates from, or a node that represents a specific thematic entry point. In general, such objects will have other attributes that will qualify the kind of the structure.]]></item>
				</item>
			</item>
		</TERM>

		<!-- kTYPE_NODE_ONTOLOGY -->
		<TERM ns=":type:node" lid="ontology">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Ontology</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>An ontology</em>. This is a graph structure that represents an ontology, the item that bares this attribute is expected to be a root node, structures of this kind usually represent the full set of elements comprising an ontology which will be used by views to create thematic selections.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_TYPE -->
		<TERM ns=":type:node" lid="type">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Type or controlled vocabulary</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A type or controlled vocabulary structure</em>. This is a structure that represents a type or controlled vocabulary, the item that bares this attribute is expected to be a root node and its structure must be a tree (at most one parent node). The main use of such a kind is to group all elements representing a type or controlled vocabulary that comprises the full set of attributes, views that reference such structures can be used to represent thematic subsets of such types or controlled vocabularies.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_NODE_VIEW -->
		<TERM ns=":type:node" lid="view">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">View</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A view of one or more structures</em>. This represents a view into an existing structure or structures, the item that bares this attribute is expected to be a root node and the structure is expected to be either a selection or an aggregation of elements from different existing structures. The main goal is to create specific thematic views.]]></item>
				</item>
			</item>
		</TERM>
		
		<!-- kTYPE_NODE_TEMPLATE -->
		<TERM ns=":type:node" lid="template">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Template</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A data template</em>. This is a view that represents a template, the item that bares this attribute is expected to be a root node and its structure must be a tree (at most one parent node). Templates are generally used to import and export data recorded using elements from the ontologies.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_FORM -->
		<TERM ns=":type:node" lid="form">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Form</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A search form</em>. This is a view that represents a search form, the item that bares this attribute is expected to be a root node and its structure must be a tree (at most one parent node). Structures of this kind can be used as search form templates where the branches represent categories and the leaf nodes the attributes to be searched.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_STRUCT -->
		<TERM ns=":type:node" lid="struct">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Structure</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A data structure</em>. This is a view that represents a data structure, the item that bares this attribute is expected to be a root node and its structure must be a tree (at most one parent node). Structures of this kind can be used as templates to define the physical structure of an object.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_SCHEMA -->
		<TERM ns=":type:node" lid="schema">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Schema</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A data schema</em>. This is a view that represents a data <em>schema or sub-structure</em>, the item that bares this attribute is expected to be a root node and its structure must be a tree (at most one parent node). Structures of this kind can be used as templates to define common schemas that will be used in data structures.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_FEATURE -->
		<TERM ns=":type:node" lid="feature">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Feature</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A feature or attribute of an object that can be described or measured</em>. This kind defines a feature, property or attribute of an object that can be described or measured. This kind of node will generally be found as a <em>leaf of the structure</em> describing an object. Plant height is a plant characteristic that belongs to the category of morphological traits: the latter is not a feature, while plant height is.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_METHOD -->
		<TERM ns=":type:node" lid="method">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Method</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>A method or variation of an object's feature measurement</em>. This kind of node is required whenever an object's feature can be <em>measured in different ways</em> or with <em>different workflows</em>, <em>without becoming a different feature</em>. Plant height is an attribute of a plant which can be measured after a month or at flowering time; the attribute is the same, but the method is different.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_SCALE -->
		<TERM ns=":type:node" lid="scale">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Scale</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>The scale or unit in which a measurement is expressed in</em>. This kind of node describes in what unit or scale a measurement is expressed in. Plant height may be measured in centimeters or inches, as well as in intervals or finite categories.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_PROPERTY -->
		<TERM ns=":type:node" lid="property">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Property</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>data property</em>. The node features a <em>reference to the tag</em> which contains all the information defining and describing a data property.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_ENUMERATED -->
		<TERM ns=":type:node" lid="enumerated">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Enumerated set</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[A <em>controlled vocabulary</em> or an <em>enumerated set subset</em>. This kind describes a set of values representing an enumerated set, the element itself is not considered as an element of the set, it defines a formal controlled vocabulary.The ISO 3166 country codes could be considered an enumerated set.]]></item>
				</item>
			</item>
		</TERM>
	
		<!-- kTYPE_NODE_ENUMERATION -->
		<TERM ns=":type:node" lid="enumeration">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Enumerated value</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[An <em>element/em> of a <em>controlled vocabulary</em>. This kind describes an item belonging to an enumerated set, the item may also be nested. An ISO 3166 country code could be considered an enumeration node.]]></item>
				</item>
			</item>
		</TERM>
	</META>
	
	<!-- Term types -->
	
	<META>
		<!-- kTYPE_TERM_INSTANCE -->
		<TERM ns=":type:term" lid="instance">
			<item const="kTAG_LABEL">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT">Instance</item>
				</item>
			</item>
			<item const="kTAG_DEFINITION">
				<item>
					<item const="kTAG_LANGUAGE">en</item>
					<item const="kTAG_TEXT"><![CDATA[<em>An instance</em> term can be considered as an instance of the <em>object it defines</em>. This type of terms will hold data, in addition to the metadata, regarding what it defines. In general, this kind of term will be an element of an enumerated set which can be used in place of what the element represents.]]></item>
				</item>
			</item>
		</TERM>
	</META>
</METADATA>
