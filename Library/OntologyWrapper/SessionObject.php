<?php

/**
 * SessionObject.php
 *
 * This file contains the definition of the {@link SessionObject} class.
 */

namespace OntologyWrapper;

use OntologyWrapper\Wrapper;
use OntologyWrapper\PersistentObject;

/*=======================================================================================
 *																						*
 *								SessionObject.php										*
 *																						*
 *======================================================================================*/

/**
 * Domains.
 *
 * This file contains the domain definitions.
 */
require_once( kPATH_DEFINITIONS_ROOT."/Domains.inc.php" );

/**
 * Session object
 *
 * This <i>abstract</i> class is the ancestor of all classes representing session or
 * transaction objects that can persist in a container and that are constituted by ontology
 * offsets.
 *
 * The class features the following default offsets:
 *
 * <ul>
 *	<li><tt>{@link kTAG_NID}</tt>: <em>Native identifier</em>. The native identifier of a
 *		session or transaction is automatically generated by the database when inserted the
 *		first time.
 *	<li><tt>{@link kTAG_USER}</tt>: <em>Requesting user</em>. The object reference for the
 *		user that launched the session or that triggered the transaction.
 *	<li><tt>{@link kTAG_SESSION}</tt>: <em>Session</em>. The object reference of the session
 *		to which the current object is related: for sessions it represents the related
 *		session, for transactions it represents the session that launched the transaction.
 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: <em>Collections count</em>. The total
 *		number of collections.
 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: <em>Records count</em>. The total number of
 *		records.
 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: <em>Fields count</em>. The total number of
 *		fields.
 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: <em>Processed elements</em>. The number of elements
 *		processed by the session, this will typically be the transactions count relating to
 *		this session.
 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: <em>Validated elements</em>. The number of elements
 *		validated by the session, this will typically be the transactions count that were
 *		cleared by the validation process.
 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: <em>Rejected elements</em>. The number of elements
 *		rejected by the session, this will typically be the transactions count that were
 *		not cleared by the validation process.
 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: <em>Skipped elements</em>. The number of elements
 *		skipped by the session, this will typically be the transactions count that were
 *		skipped by the validation process; such as empty data template lines.
 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: <em>Progress</em>. The current progress
 *		percentage: it is the percentage of the processed count by one of the three above
 *		properties.
 * </ul>
 *
 * The last eight properties can only be set externally by sending a modification request to
 * the database, you can consider these <tt>extern</tt> variables and their counterpart
 * offsets in the object should not be trusted. The first three properties can be set and
 * queried using this interface:
 *
 * <ul>
 *	<li><tt>{@link totalCollections()}</tt>: Handles the {@link kTAG_COUNTER_COLLECTIONS}
 *		property.
 *	<li><tt>{@link totalRecords()}</tt>: Handles the {@link kTAG_COUNTER_RECORDS} property.
 *	<li><tt>{@link totalFields()}</tt>: Handles the {@link kTAG_COUNTER_FIELDS} property.
 * </ul>
 *
 * The remaining five properties can either be incremented or retrieved:
 *
 * <ul>
 *	<li><tt>{@link processed()}</tt>: Handles the {@link kTAG_COUNTER_PROCESSED} property.
 *	<li><tt>{@link validated()}</tt>: Handles the {@link kTAG_COUNTER_VALIDATED} property.
 *	<li><tt>{@link rejected()}</tt>: Handles the {@link kTAG_COUNTER_REJECTED} property.
 *	<li><tt>{@link skipped()}</tt>: Handles the {@link kTAG_COUNTER_SKIPPED} property.
 * </ul>
 *
 * The main purpose of this class is to implement abstract methods common to all session
 * objects.
 *
 *	@author		Milko A. Škofič <m.skofic@cgiar.org>
 *	@version	1.00 13/02/2014
 */
abstract class SessionObject extends PersistentObject
{
		

/*=======================================================================================
 *																						*
 *										MAGIC											*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	__construct																		*
	 *==================================================================================*/

	/**
	 * Instantiate class.
	 *
	 * Objects derived from this class feature a native identifier, in this class we convert
	 * string identifiers to this type.
	 *
	 * We also assert that the container is provided and is a wrapper.
	 *
	 * @param ConnectionObject		$theContainer		Persistent store.
	 * @param mixed					$theIdentifier		Object identifier.
	 *
	 * @access public
	 *
	 * @throws Exception
	 */
	public function __construct( $theContainer = NULL, $theIdentifier = NULL )
	{
		//
		// Assert container.
		//
		if( $theContainer !== NULL )
		{
			//
			// Assert wrapper.
			//
			if( $theContainer instanceof Wrapper )
			{
				//
				// Normalise identifier.
				//
				if( ($theIdentifier !== NULL)
				 && (! is_array( $theIdentifier )) )
				{
					$tmp =
						static::ResolveCollection(
							static::ResolveDatabase( $theContainer, TRUE ) )
								->getObjectId( $theIdentifier );
					if( $tmp === NULL )
						throw new \Exception(
							"Cannot use identifier: "
						   ."invalid object identifier [$theIdentifier]." );	// !@! ==>
					$theIdentifier = $tmp;
				}
		
				//
				// Call parent method.
				// Note that we assert the object's existance.
				//
				parent::__construct( $theContainer, $theIdentifier, TRUE );
			
			} // Provided container.
			
			else
				throw new \Exception(
					"Cannot instantiate object: "
				   ."expecting the data wrapper." );							// !@! ==>
		
		} // Provided container.
		
		else
			throw new \Exception(
				"Cannot instantiate object: "
			   ."expecting the container." );									// !@! ==>

	} // Constructor.

	 
	/*===================================================================================
	 *	__toString																		*
	 *==================================================================================*/

	/**
	 * <h4>Return global identifier</h4>
	 *
	 * In this class we return the string representation of the native identifier.
	 *
	 * @access public
	 * @return string				The persistent identifier as a string.
	 *
	 * @see kTAG_NID
	 */
	public function __toString()
	{
		//
		// Check persistent identifier.
		//
		if( \ArrayObject::offsetExists( kTAG_NID ) )
			return (string) \ArrayObject::offsetGet( kTAG_NID );					// ==>
		
		return '';																	// ==>
	
	} // __toString.

		

/*=======================================================================================
 *																						*
 *								PUBLIC PERSISTENCE INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	insert																			*
	 *==================================================================================*/

	/**
	 * Insert the object
	 *
	 * We overload this method to cast the native identifier to a string.
	 *
	 * @param Wrapper				$theWrapper			Data wrapper.
	 * @param bitfield				$theOptions			Operation options.
	 *
	 * @access public
	 * @return mixed				The object's native identifier or <tt>NULL</tt>.
	 */
	public function insert( $theWrapper = NULL, $theOptions = kFLAG_OPT_REL_ONE )
	{
		return
			static::ResolveCollection(
				static::ResolveDatabase( $theWrapper, TRUE ), TRUE )
					->setObjectId( parent::insert( $theWrapper, $theOptions ) );	// ==>
	
	} // insert.

	 
	/*===================================================================================
	 *	commit																			*
	 *==================================================================================*/

	/**
	 * Commit the object
	 *
	 * We overload this method to cast the native identifier to a string.
	 *
	 * @param Wrapper				$theWrapper			Data wrapper.
	 * @param bitfield				$theOptions			Operation options.
	 *
	 * @access public
	 * @return mixed				The object's native identifier.
	 */
	public function commit( $theWrapper = NULL, $theOptions = kFLAG_OPT_REL_ONE )
	{
		//
		// Resolve wrapper.
		//
		$this->resolveWrapper( $theWrapper );
		
		return
			static::ResolveCollection(
				static::ResolveDatabase( $theWrapper, TRUE ), TRUE )
					->setObjectId( parent::commit( $theWrapper, $theOptions ) );	// ==>
	
	} // commit.

		

/*=======================================================================================
 *																						*
 *								PUBLIC REFERENCE INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	getParentSession																*
	 *==================================================================================*/

	/**
	 * Get parent session
	 *
	 * This method will return the referencing session if set and committed; if none of
	 * these two conditions are true, the method will return <tt>NULL</tt>.
	 *
	 * @access public
	 * @return Session				Referencing session or <tt>NULL</tt>.
	 *
	 * @see kTAG_SESSION
	 *
	 * @uses resolvePersistent()
	 */
	public function getParentSession()
	{
		//
		// Check if committed.
		//
		if( $this->committed() )
		{
			//
			// Check if set.
			//
			$id = $this->resolvePersistent( TRUE )->offsetGet( kTAG_SESSION );
			if( $id !== NULL )
				return
					Session::ResolveCollection(
						Session::ResolveDatabase( $this->mDictionary, TRUE ), TRUE )
							->matchOne( array( kTAG_NID => $id ),
										kQUERY_OBJECT | kQUERY_ASSERT );			// ==>
		
		} // Is committed.
		
		return NULL;																// ==>
	
	} // getParentSession.

		

/*=======================================================================================
 *																						*
 *							PUBLIC EXTERN COUNTERS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	progress																		*
	 *==================================================================================*/

	/**
	 * Manage the progress
	 *
	 * This method will either retrieve the current progress count from the persistent
	 * object, or increment the count by the provided value.
	 *
	 * If the parameter is <tt>NULL</tt>, the method will retrieve the count; if not,
	 * the method will cast the parameter to an integer and update the count of the
	 * persistent object by that value and return it.
	 *
	 * The current object's count will not be updated, because of this, the count should not
	 * be counted on :-)
	 *
	 * @param mixed					$theValue			Increment delta or <tt>NULL</tt>.
	 *
	 * @access public
	 * @return int					Current count or increment.
	 *
	 * @see kTAG_COUNTER_PROGRESS
	 *
	 * @uses resolvePersistent()
	 * @uses updateCount()
	 */
	public function progress( $theValue = NULL )
	{
		//
		// Retrieve count.
		//
		if( $theValue === NULL )
			return
				$this->resolvePersistent( TRUE )
					->offsetGet( kTAG_COUNTER_PROGRESS );							// ==>
		
		//
		// Update count.
		//
		$this->updateCount( kTAG_COUNTER_PROGRESS, (int) $theValue );
		
		return (int) $theValue;														// ==>
	
	} // progress.

	 
	/*===================================================================================
	 *	processed																		*
	 *==================================================================================*/

	/**
	 * Manage the processed count
	 *
	 * This method will either retrieve the current processed count from the persistent
	 * object, or increment the count by the provided value.
	 *
	 * If the first parameter is <tt>NULL</tt>, the method will retrieve the count; if not,
	 * the method will cast the parameter to an integer and update the count of the
	 * persistent object by that value and return it.
	 *
	 * The second parameter is relevant only if the first parameter is an increment: it
	 * represents the totals offset that should be used to calculate the progress: when
	 * provided, the method will also update the persistent object's progress.
	 *
	 * The current object's count will not be updated, because of this, the count should not
	 * be counted on :-)
	 *
	 * @param mixed					$theValue			Increment delta or <tt>NULL</tt>.
	 * @param string				$theTotal			Total count offset.
	 *
	 * @access public
	 * @return int					Current count or increment.
	 *
	 * @see kTAG_COUNTER_PROCESSED
	 *
	 * @uses resolvePersistent()
	 * @uses updateCount()
	 */
	public function processed( $theValue = NULL, $theTotal = NULL )
	{
		//
		// Retrieve count.
		//
		if( $theValue === NULL )
			return
				$this->resolvePersistent( TRUE )
					->offsetGet( kTAG_COUNTER_PROCESSED );							// ==>
		
		//
		// Update count.
		//
		$this->updateCount( kTAG_COUNTER_PROCESSED, (int) $theValue, $theTotal );
		
		return (int) $theValue;														// ==>
	
	} // processed.

	 
	/*===================================================================================
	 *	validated																		*
	 *==================================================================================*/

	/**
	 * Manage the validated count
	 *
	 * This method will either retrieve the current validated count from the persistent
	 * object, or increment the count by the provided value.
	 *
	 * If the first parameter is <tt>NULL</tt>, the method will retrieve the count; if not,
	 * the method will cast the parameter to an integer and update the count of the
	 * persistent object by that value and return it.
	 *
	 * The second parameter is relevant only if the first parameter is an increment: it
	 * represents the totals offset that should be used to calculate the progress: when
	 * provided, the method will also update the persistent object's progress.
	 *
	 * The current object's count will not be updated, because of this, the count should not
	 * be counted on :-)
	 *
	 * @param mixed					$theValue			Increment delta or <tt>NULL</tt>.
	 * @param string				$theTotal			Total count offset.
	 *
	 * @access public
	 * @return int					Current count or increment.
	 *
	 * @see kTAG_COUNTER_VALIDATED
	 *
	 * @uses resolvePersistent()
	 * @uses updateCount()
	 */
	public function validated( $theValue = NULL, $theTotal = NULL )
	{
		//
		// Retrieve count.
		//
		if( $theValue === NULL )
			return
				$this->resolvePersistent( TRUE )
					->offsetGet( kTAG_COUNTER_VALIDATED );							// ==>
		
		//
		// Update count.
		//
		$this->updateCount( kTAG_COUNTER_VALIDATED, (int) $theValue, $theTotal );
		
		return (int) $theValue;														// ==>
	
	} // validated.

	 
	/*===================================================================================
	 *	rejected																		*
	 *==================================================================================*/

	/**
	 * Manage the rejected count
	 *
	 * This method will either retrieve the current rejected count from the persistent
	 * object, or increment the count by the provided value.
	 *
	 * If the first parameter is <tt>NULL</tt>, the method will retrieve the count; if not,
	 * the method will cast the parameter to an integer and update the count of the
	 * persistent object by that value and return it.
	 *
	 * The second parameter is relevant only if the first parameter is an increment: it
	 * represents the totals offset that should be used to calculate the progress: when
	 * provided, the method will also update the persistent object's progress.
	 *
	 * The current object's count will not be updated, because of this, the count should not
	 * be counted on :-)
	 *
	 * @param mixed					$theValue			Increment delta or <tt>NULL</tt>.
	 * @param string				$theTotal			Total count offset.
	 *
	 * @access public
	 * @return int					Current count or increment.
	 *
	 * @see kTAG_COUNTER_REJECTED
	 *
	 * @uses resolvePersistent()
	 * @uses updateCount()
	 */
	public function rejected( $theValue = NULL, $theTotal = NULL )
	{
		//
		// Retrieve count.
		//
		if( $theValue === NULL )
			return
				$this->resolvePersistent( TRUE )
					->offsetGet( kTAG_COUNTER_REJECTED );							// ==>
		
		//
		// Update count.
		//
		$this->updateCount( kTAG_COUNTER_REJECTED, (int) $theValue, $theTotal );
		
		return (int) $theValue;														// ==>
	
	} // rejected.

	 
	/*===================================================================================
	 *	skipped																			*
	 *==================================================================================*/

	/**
	 * Manage the skipped count
	 *
	 * This method will either retrieve the current skipped count from the persistent
	 * object, or increment the count by the provided value.
	 *
	 * If the first parameter is <tt>NULL</tt>, the method will retrieve the count; if not,
	 * the method will cast the parameter to an integer and update the count of the
	 * persistent object by that value and return it.
	 *
	 * The second parameter is relevant only if the first parameter is an increment: it
	 * represents the totals offset that should be used to calculate the progress: when
	 * provided, the method will also update the persistent object's progress.
	 *
	 * The current object's count will not be updated, because of this, the count should not
	 * be counted on :-)
	 *
	 * @param mixed					$theValue			Increment delta or <tt>NULL</tt>.
	 * @param string				$theTotal			Total count offset.
	 *
	 * @access public
	 * @return int					Current count or increment.
	 *
	 * @see kTAG_COUNTER_SKIPPED
	 *
	 * @uses resolvePersistent()
	 * @uses updateCount()
	 */
	public function skipped( $theValue = NULL, $theTotal = NULL )
	{
		//
		// Retrieve count.
		//
		if( $theValue === NULL )
			return
				$this->resolvePersistent( TRUE )
					->offsetGet( kTAG_COUNTER_SKIPPED );							// ==>
		
		//
		// Update count.
		//
		$this->updateCount( kTAG_COUNTER_SKIPPED, (int) $theValue, $theTotal );
		
		return (int) $theValue;														// ==>
	
	} // skipped.

		

/*=======================================================================================
 *																						*
 *							PUBLIC EXTERN COUNTERS RETRIEVAL							*
 *																						*
 *======================================================================================*/


		
	/*===================================================================================
	 *	counters																		*
	 *==================================================================================*/

	/**
	 * Retrieve operation counters
	 *
	 * This method can be used to retrieve the current operations counters, the method will
	 * return an array with the following keys:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * The method will fetch the information from the persistent object, this means that if
	 * the current object is not committed, the method will generate an exception.
	 *
	 * @access public
	 * @return array				Operation counters.
	 *
	 * @uses session()
	 */
	public function counters()
	{
		//
		// Init local storage.
		//
		$result = Array();
		$counters
			= array( kTAG_COUNTER_COLLECTIONS, kTAG_COUNTER_RECORDS, kTAG_COUNTER_FIELDS,
					 kTAG_COUNTER_SKIPPED, kTAG_COUNTER_REJECTED,
					 kTAG_COUNTER_VALIDATED, kTAG_COUNTER_PROCESSED,
					 kTAG_COUNTER_PROGRESS );
		
		//
		// Get persistent copy.
		//
		$data = $this->resolvePersistent( TRUE )->getArrayCopy();
		
		//
		// Set counters.
		//
		foreach( $counters as $counter )
		{
			if( array_key_exists( $counter, $data ) )
				$result[ $counter ] = $data[ $counter ];
		}
		
		return $result;																// ==>
	
	} // counters.

		

/*=======================================================================================
 *																						*
 *								PUBLIC ARRAY ACCESS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	offsetExists																	*
	 *==================================================================================*/

	/**
	 * Check if an offset exists
	 *
	 * We overload this method to intercept extern properties, these are prompted from the
	 * database rather than from the object when the latter is committed: these are the
	 * extern offsets:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Validated elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Rejected elements.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Skipped elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * @param mixed					$theOffset			Offset.
	 *
	 * @access public
	 * @return boolean				<tt>TRUE</tt> the offset exists.
	 *
	 * @throws Exception
	 *
	 * @uses resolvePersistent()
	 */
	public function offsetExists( $theOffset )
	{
		//
		// Handle committed object.
		//
		if( $this->committed() )
		{
			//
			// Resolve offset.
			//
			$theOffset = $this->resolveOffset( $theOffset );
	
			//
			// Handle extern properties.
			//
			switch( $theOffset )
			{
				case kTAG_FILE:
				case kTAG_COUNTER_COLLECTIONS:
				case kTAG_COUNTER_RECORDS:
				case kTAG_COUNTER_FIELDS:
				case kTAG_COUNTER_PROCESSED:
				case kTAG_COUNTER_VALIDATED:
				case kTAG_COUNTER_REJECTED:
				case kTAG_COUNTER_SKIPPED:
				case kTAG_COUNTER_PROGRESS:
				
					return
						in_array(
							$theOffset,
							$this->resolvePersistent( TRUE )->arrayKeys() );		// ==>
			
			} // Extern offset.
		
		} // Is committed.
		
		return parent::offsetExists( $theOffset );									// ==>
	
	} // offsetExists.

	 
	/*===================================================================================
	 *	offsetGet																		*
	 *==================================================================================*/

	/**
	 * Return a value at a given offset
	 *
	 * We overload this method to intercept extern properties, these are prompted from the
	 * database rather than from the object when the latter is committed: these are the
	 * extern offsets:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Validated elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Rejected elements.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Skipped elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * Note that this method will consider the offset extern, only if provided as an offset,
	 * if provided as a tag native identifier it will function in the default manner.
	 *
	 * @param mixed					$theOffset			Offset.
	 *
	 * @access public
	 * @return mixed				Offset value or <tt>NULL</tt>.
	 *
	 * @throws Exception
	 *
	 * @uses resolvePersistent()
	 */
	public function offsetGet( $theOffset )
	{
		//
		// Handle committed object.
		//
		if( $this->committed() )
		{
			//
			// Resolve offset.
			//
			$theOffset = $this->resolveOffset( $theOffset );
	
			//
			// Handle extern properties.
			//
			switch( $theOffset )
			{
				case kTAG_FILE:
				case kTAG_COUNTER_COLLECTIONS:
				case kTAG_COUNTER_RECORDS:
				case kTAG_COUNTER_FIELDS:
				case kTAG_COUNTER_PROCESSED:
				case kTAG_COUNTER_VALIDATED:
				case kTAG_COUNTER_REJECTED:
				case kTAG_COUNTER_SKIPPED:
				case kTAG_COUNTER_PROGRESS:
			
					//
					// Get persistent object.
					//
					$persistent = $this->resolvePersistent( TRUE )->getArrayCopy();
			
					return ( array_key_exists( $theOffset, $persistent ) )
						 ? $persistent[ $theOffset ]								// ==>
						 : NULL;													// ==>
					
			} // Extern offset.
		
		} // Is committed.
		
		return parent::offsetGet( $theOffset );										// ==>
	
	} // offsetGet.

	 
	/*===================================================================================
	 *	offsetSet																		*
	 *==================================================================================*/

	/**
	 * Set a value at a given offset
	 *
	 * We overload this method to intercept extern properties, these are set in the database
	 * rather than from the object when the latter is committed: these are the extern
	 * offsets:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Validated elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Rejected elements.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Skipped elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * Note that this method will consider the offset extern, only if provided as an offset,
	 * if provided as a tag native identifier it will function in the default manner.
	 *
	 * @param string				$theOffset			Offset.
	 * @param mixed					$theValue			Value to set at offset.
	 *
	 * @access public
	 *
	 * @uses resolvePersistent()
	 */
	public function offsetSet( $theOffset, $theValue )
	{
		//
		// Handle committed objects.
		//
		if( $this->committed() )
		{
			//
			// Resolve offset.
			//
			$theOffset = $this->resolveOffset( $theOffset );
	
			//
			// Handle extern properties.
			//
			switch( $theOffset )
			{
				case kTAG_FILE:
				case kTAG_COUNTER_COLLECTIONS:
				case kTAG_COUNTER_RECORDS:
				case kTAG_COUNTER_FIELDS:
				case kTAG_COUNTER_PROCESSED:
				case kTAG_COUNTER_VALIDATED:
				case kTAG_COUNTER_REJECTED:
				case kTAG_COUNTER_SKIPPED:
				case kTAG_COUNTER_PROGRESS:
		
					//
					// Set in persistent object.
					//
					static::ResolveCollection(
						static::ResolveDatabase( $this->mDictionary, TRUE ), TRUE )
							->replaceOffsets(
								$this->offsetGet( kTAG_NID ),
								array( $theOffset => $theValue ) );
				
					break;
					
			} // Extern offset.
		
		} // Is committed.
		
		//
		// Call parent method.
		//
		parent::offsetSet( $theOffset, $theValue );
	
	} // offsetSet.

	 
	/*===================================================================================
	 *	offsetUnset																		*
	 *==================================================================================*/

	/**
	 * Reset a value at a given offset
	 *
	 * We overload this method to intercept extern properties, these are unset in the
	 * database rather than from the object when the latter is committed: these are the
	 * extern offsets:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Validated elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Rejected elements.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Skipped elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * @param string				$theOffset			Offset.
	 *
	 * @access public
	 *
	 * @uses nestedOffsetUnset()
	 */
	public function offsetUnset( $theOffset )
	{
		//
		// Handle committed objects.
		//
		if( $this->committed() )
		{
			//
			// Resolve offset.
			//
			$theOffset = $this->resolveOffset( $theOffset );
	
			//
			// Handle extern properties.
			//
			switch( $theOffset )
			{
				case kTAG_FILE:
				case kTAG_COUNTER_COLLECTIONS:
				case kTAG_COUNTER_RECORDS:
				case kTAG_COUNTER_FIELDS:
				case kTAG_COUNTER_PROCESSED:
				case kTAG_COUNTER_VALIDATED:
				case kTAG_COUNTER_REJECTED:
				case kTAG_COUNTER_SKIPPED:
				case kTAG_COUNTER_PROGRESS:
		
					//
					// Unset in persistent object.
					//
					static::ResolveCollection(
						static::ResolveDatabase( $this->mDictionary, TRUE ), TRUE )
							->replaceOffsets(
								$this->offsetGet( kTAG_NID ),
									array( $theOffset => NULL ) );
				
					break;
					
			} // Extern offset.
		
		} // Is committed.
		
		//
		// Call parent method.
		//
		parent::offsetUnset( $theOffset );
	
	} // offsetUnset.

	

/*=======================================================================================
 *																						*
 *								PUBLIC OPERATIONS INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	newTransaction																	*
	 *==================================================================================*/

	/**
	 * Create transaction
	 *
	 * This method can be used to create a transaction referenced by the current object,
	 * holding the provided parameters; the transaction will be committed by this method.
	 *
	 * If the current object is not committed, the method will raise an exception.
	 *
	 * @param string				$theType			Transaction type.
	 * @param string				$theStatus			Transaction status.
	 * @param string				$theCollection		Transaction collection.
	 * @param int					$theRecord			Transaction record.
	 *
	 * @access public
	 * @return Transaction			Transaction object.
	 *
	 * @throws Exception
	 *
	 * @uses committed()
	 */
	public function newTransaction( $theType, $theStatus = NULL,
											  $theCollection = NULL,
											  $theRecord = NULL )
	{
		//
		// Check if committed.
		//
		if( $this->committed() )
		{
			//
			// Init local storage.
			//
			$id = $this->offsetGet( kTAG_NID );
			
			//
			// Instantiate object.
			//
			$transaction = new Transaction( $this->mDictionary );
			
			//
			// Set status.
			//
			if( $theStatus !== NULL )
				$transaction->offsetSet( kTAG_TRANSACTION_STATUS, $theStatus );
			
			//
			// Handle session.
			//
			if( $this instanceof Session )
			{
				$transaction->offsetSet( kTAG_SESSION, $id );
				$transaction->offsetSet( kTAG_USER, $this->offsetGet( kTAG_USER ) );
			
			} // Session.
			
			//
			// Handle transaction.
			//
			elseif( $this instanceof Transaction )
				$transaction->offsetSet( kTAG_TRANSACTION, $id );
		
			//
			// Set type.
			//
			$transaction->offsetSet( kTAG_TRANSACTION_TYPE, $theType );
		
			//
			// Set collection.
			//
			if( $theCollection !== NULL )
				$transaction->offsetSet( kTAG_TRANSACTION_COLLECTION, $theCollection );
		
			//
			// Set record.
			//
			if( $theRecord !== NULL )
				$transaction->offsetSet( kTAG_TRANSACTION_RECORD, $theRecord );
			
			//
			// Commit transaction.
			//
			$transaction->commit();
			
			return $transaction;													// ==>
		
		} // Object is committed.
		
		throw new \Exception(
			"Cannot create transaction: "
		   ."the object is not committed." );									// !@! ==>
	
	} // newTransaction.

		

/*=======================================================================================
 *																						*
 *								STATIC PERSISTENCE INTERFACE							*
 *																						*
 *======================================================================================*/


		
	/*===================================================================================
	 *	Delete																			*
	 *==================================================================================*/

	/**
	 * Delete an object
	 *
	 * We overload this method to normalise the identifier.
	 *
	 * @param Wrapper				$theWrapper			Data wrapper.
	 * @param mixed					$theIdentifier		Object native identifier.
	 *
	 * @static
	 * @return mixed				Identifier, <tt>NULL</tt> or <tt>FALSE</tt>.
	 *
	 * @throws Exception
	 *
	 * @uses ResolveDatabase()
	 * @uses ResolveCollection()
	 */
	static function Delete( Wrapper $theWrapper, $theIdentifier )
	{
		//
		// Get collection.
		//
		$collection
			= static::ResolveCollection(
				static::ResolveDatabase( $theWrapper, TRUE ) );
		
		//
		// Perform deletion.
		//
		$tmp = $collection->getObjectId( $theIdentifier );
		if( $tmp === NULL )
			throw new \Exception(
				"Cannot use identifier: "
			   ."invalid object identifier [$theIdentifier]." );				// !@! ==>
		$theIdentifier = parent::Delete( $theWrapper, $tmp );
		
		return ( $theIdentifier === NULL )
			 ? NULL																	// ==>
			 : $collection->setObjectId( $theIdentifier );							// ==>
	
	} // Delete.

	 

/*=======================================================================================
 *																						*
 *								STATIC CONNECTION INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	ResolveDatabase																	*
	 *==================================================================================*/

	/**
	 * Resolve the database
	 *
	 * In this class we use the {@link User::ResolveDatabase()} method.
	 *
	 * @param Wrapper				$theWrapper			Wrapper.
	 * @param boolean				$doAssert			Raise exception if unable.
	 * @param boolean				$doOpen				<tt>TRUE</tt> open connection.
	 *
	 * @static
	 * @return DatabaseObject		Database or <tt>NULL</tt>.
	 */
	static function ResolveDatabase( Wrapper $theWrapper, $doAssert = TRUE, $doOpen = TRUE )
	{
		return User::ResolveDatabase( $theWrapper, $doAssert, $doOpen );			// ==>
	
	} // ResolveDatabase.

		

/*=======================================================================================
 *																						*
 *								STATIC DICTIONARY INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	UnmanagedOffsets																*
	 *==================================================================================*/

	/**
	 * Return unmanaged offsets
	 *
	 * In this class we exclude all extern offsets, this includes:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_SESSION}</tt>: Session reference.
	 *	<li><tt>{@link kTAG_COUNTER_COLLECTIONS}</tt>: Collections count.
	 *	<li><tt>{@link kTAG_COUNTER_RECORDS}</tt>: Records count.
	 *	<li><tt>{@link kTAG_COUNTER_FIELDS}</tt>: Fields count.
	 *	<li><tt>{@link kTAG_COUNTER_PROCESSED}</tt>: Processed elements.
	 *	<li><tt>{@link kTAG_COUNTER_VALIDATED}</tt>: Validated elements.
	 *	<li><tt>{@link kTAG_COUNTER_REJECTED}</tt>: Rejected elements.
	 *	<li><tt>{@link kTAG_COUNTER_SKIPPED}</tt>: Skipped elements.
	 *	<li><tt>{@link kTAG_COUNTER_PROGRESS}</tt>: Progress.
	 * </ul>
	 *
	 * @static
	 * @return array				List of unmanaged offsets.
	 *
	 * @see kTAG_COUNTER_FIELDS kTAG_COUNTER_RECORDS kTAG_COUNTER_COLLECTIONS
	 * @see kTAG_COUNTER_PROCESSED kTAG_COUNTER_VALIDATED
	 * @see kTAG_COUNTER_REJECTED kTAG_COUNTER_SKIPPED
	 * @see kTAG_COUNTER_PROGRESS
	 */
	static function UnmanagedOffsets()
	{
		return array_merge(
			parent::UnmanagedOffsets(),
			array( kTAG_FILE, kTAG_SESSION,
				   kTAG_COUNTER_COLLECTIONS, kTAG_COUNTER_RECORDS, kTAG_COUNTER_FIELDS,
				   kTAG_COUNTER_PROCESSED, kTAG_COUNTER_VALIDATED,
				   kTAG_COUNTER_REJECTED, kTAG_COUNTER_SKIPPED,
				   kTAG_COUNTER_PROGRESS ) );										// ==>
	
	} // UnmanagedOffsets.

		

/*=======================================================================================
 *																						*
 *							PROTECTED ARRAY ACCESS INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preOffsetSet																	*
	 *==================================================================================*/

	/**
	 * Handle offset and value before setting it
	 *
	 * We overload this method to normalise:
	 *
	 * <ul>
	 *	<li><tt>{@link kTAG_FILE}</tt>: File reference.
	 *	<li><tt>{@link kTAG_SESSION}</tt>: Session reference.
	 * </ul>
	 *
	 * @param reference				$theOffset			Offset reference.
	 * @param reference				$theValue			Offset value reference.
	 *
	 * @access protected
	 * @return mixed				<tt>NULL</tt> set offset value, other, return.
	 *
	 * @throws Exception
	 *
	 * @uses isConnected()
	 */
	protected function preOffsetSet( &$theOffset, &$theValue )
	{
		//
		// Normalise value.
		//
		switch( $this->resolveOffset( $theOffset ) )
		{
			case kTAG_FILE:
			
				//
				// Normalise identifier.
				//
				if( $theValue instanceof FileObject )
					$theValue = $theValue->offsetGet( kTAG_NID );
				else
				{
					$id
						= FileObject::ResolveCollection(
							FileObject::ResolveDatabase( $this->mDictionary, TRUE ), TRUE )
								->getObjectId( $theValue );
					if( $id === NULL )
						throw new \Exception(
							"Cannot use identifier: "
						   ."invalid file identifier [$theValue]." );			// !@! ==>
					$theValue = $id;
				}
				
				break;
				
			case kTAG_SESSION:
				
				//
				// Normalise identifier.
				//
				if( $theValue instanceof Session )
					$theValue = $theValue->offsetGet( kTAG_NID );
				else
				{
					$id
						= Session::ResolveCollection(
							Session::ResolveDatabase( $this->mDictionary, TRUE ), TRUE )
								->getObjectId( $theValue );
					if( $id === NULL )
						throw new \Exception(
							"Cannot use identifier: "
						   ."invalid session identifier [$theValue]." );		// !@! ==>
					$theValue = $id;
				}
				
				break;
		}
		
		return parent::preOffsetSet( $theOffset, $theValue );						// ==>
	
	} // preOffsetSet.

	

/*=======================================================================================
 *																						*
 *								STATIC EXPORT INTERFACE									*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	XMLRootElement																	*
	 *==================================================================================*/

	/**
	 * Return XML root element
	 *
	 * In this class we return the <tt>UNITS</tt> root element.
	 *
	 * @static
	 * @return SimpleXMLElement		XML export root element.
	 */
	static function XMLRootElement()
	{
		return new \SimpleXMLElement(
						str_replace(
							'@@@', kIO_XML_UNITS, kXML_STANDARDS_BASE ) );			// ==>
	
	} // XMLRootElement.

		

/*=======================================================================================
 *																						*
 *								PROTECTED EXPORT UTILITIES								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	xmlUnitElement																	*
	 *==================================================================================*/

	/**
	 * Return XML unit element
	 *
	 * In this class we return the <tt>UNIT</tt> element.
	 *
	 * @param SimpleXMLElement		$theRoot			Root container.
	 *
	 * @access protected
	 * @return SimpleXMLElement		XML export unit element.
	 */
	protected function xmlUnitElement( \SimpleXMLElement $theRoot )
	{
		return $theRoot->addChild( kIO_XML_TRANS_UNITS );							// ==>
	
	} // xmlUnitElement.

		

/*=======================================================================================
 *																						*
 *							PROTECTED PERSISTENCE INTERFACE								*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	updateObject																	*
	 *==================================================================================*/

	/**
	 * Update the object
	 *
	 * We overload this method to prevent updating an existing session, if called, this
	 * method will raise an exception.
	 *
	 * @param CollectionObject		$theCollection		Data collection.
	 * @param bitfield				$theOptions			Operation options.
	 *
	 * @access protected
	 * @return mixed				The object's native identifier.
	 *
	 * @throws Exception
	 */
	protected function updateObject( CollectionObject $theCollection, $theOptions )
	{
		throw new \Exception(
			"Cannot update object: "
		   ."sessions can only be inserted." );									// !@! ==>
	
	} // updateObject.

		

/*=======================================================================================
 *																						*
 *								PROTECTED PRE-COMMIT INTERFACE							*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	preCommitPrepare																*
	 *==================================================================================*/

	/**
	 * Prepare object before commit
	 *
	 * In this class we initialise the operation counters.
	 *
	 * @param reference				$theTags			Property tags and offsets.
	 * @param reference				$theRefs			Object references.
	 *
	 * @access protected
	 *
	 * @see kTAG_COUNTER_PROCESSED kTAG_COUNTER_VALIDATED kTAG_COUNTER_REJECTED kTAG_COUNTER_SKIPPED
	 *
	 * @uses start()
	 */
	protected function preCommitPrepare( &$theTags, &$theRefs )
	{
		//
		// Initialise session progress.
		//
		if( ! $this->offsetExists( kTAG_COUNTER_PROGRESS ) )
			$this->offsetSet( kTAG_COUNTER_PROGRESS, 0 );
		
		//
		// Call parent method.
		//
		parent::preCommitPrepare( $theTags, $theRefs );
		
	} // preCommitPrepare.

		

/*=======================================================================================
 *																						*
 *						PROTECTED EXTERN MEMBER MANAGEMENT INTERFACE					*
 *																						*
 *======================================================================================*/


	 
	/*===================================================================================
	 *	updateCount																		*
	 *==================================================================================*/

	/**
	 * Update a counter
	 *
	 * This method will update the count of the provided offset by the provided delta of the
	 * persistent object.
	 *
	 * If the third parameter is provided, the {@link kTAG_COUNTER_PROGRESS} persistent
	 * property will also be updated using the persistent value as the totals reference.
	 *
	 * @param string				$theCounter			Counter offset.
	 * @param int					$theCount			Increment delta.
	 * @param string				$theTotal			Total count offset.
	 *
	 * @access protected
	 *
	 * @throws Exception
	 *
	 * @see kTAG_COUNTER_PROCESSED kTAG_COUNTER_VALIDATED
	 * @see kTAG_COUNTER_REJECTED kTAG_COUNTER_SKIPPED
	 * @see kTAG_COUNTER_FIELDS kTAG_COUNTER_RECORDS kTAG_COUNTER_COLLECTIONS
	 * @see kTAG_COUNTER_PROGRESS
	 */
	protected function updateCount( $theCounter, $theCount, $theTotal = NULL )
	{
		//
		// Check counter.
		//
		switch( $theCounter )
		{
			case kTAG_COUNTER_PROGRESS:
			case kTAG_COUNTER_PROCESSED:
			case kTAG_COUNTER_VALIDATED:
			case kTAG_COUNTER_REJECTED:
			case kTAG_COUNTER_SKIPPED:
				break;
		
			default:
				throw new \Exception(
					"Cannot increment counter: "
				   ."invalid counter reference [$theCounter]." );				// !@! ==>
	
		} // Valid counter.
		
		//
		// Check identifier.
		//
		if( ! $this->offsetExists( kTAG_NID ) )
			throw new \Exception(
				"Cannot increment counter: "
			   ."missing object identifier." );									// !@! ==>
		
		//
		// Update count.
		//
		static::ResolveCollection(
			static::ResolveDatabase( $this->mDictionary, TRUE ) )
				->updateReferenceCount(
					array( kTAG_NID => $this->offsetGet( kTAG_NID ) ),
					array( $theCounter => (int) $theCount ) );
		
		//
		// Handle progress.
		//
		if( $theTotal !== NULL )
		{
			//
			// Get current counters.
			//
			$counters = $this->counters();
			
			//
			// Calculate progress.
			//
			$progress = ( array_key_exists( $theTotal, $counters )
					   && array_key_exists( $theCounter, $counters ) )
					  ? ( $counters[ $theCounter ] * 100 ) / $counters[ $theTotal ]
					  : 0;
			
			//
			// Update progress in persistent object.
			//
			$this->offsetSet( kTAG_COUNTER_PROGRESS, $progress );
		
		} // Provided total.
	
	} // updateCount.

	 

} // class SessionObject.


?>
